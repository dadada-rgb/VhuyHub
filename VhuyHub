pcall(function()
    -- Xóa ScreenGui chính và GUI phụ
    local pg = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
    if pg then
        for _, gui in ipairs(pg:GetChildren()) do
            if gui.Name == "DhuyxMenu" or gui.Name == "VhuyIntroGui" or gui.Name == "CButtonGui" or gui.Name == "SafeESP" then
                gui:Destroy()
            end
        end
    end

    -- Xóa tool click TP nếu có
    local bp = game.Players.LocalPlayer:FindFirstChild("Backpack")
    if bp then
        local tool = bp:FindFirstChild("ClickTP")
        if tool then tool:Destroy() end
    end

    -- Tắt noclip nếu đang bật
    if getgenv().noclipConnection and typeof(getgenv().noclipConnection) == "RBXScriptConnection" then
        getgenv().noclipConnection:Disconnect()
        getgenv().noclipConnection = nil
    end

    -- Tắt fling
    getgenv().hiddenFling = false

    -- Xóa ESP nếu còn tồn tại
    if getgenv().ESPs then
        for _, esp in pairs(getgenv().ESPs) do
            pcall(function()
                if esp.label then esp.label:Destroy() end
                if esp.highlight then esp.highlight:Destroy() end
            end)
        end
        getgenv().ESPs = {}
    end

    -- Ngắt tất cả kết nối đã lưu
    if getgenv().Connections then
        for _, conn in pairs(getgenv().Connections) do
            pcall(function() conn:Disconnect() end)
        end
        getgenv().Connections = {}
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local HttpService = game:GetService("HttpService")
local LocalPlayer = game:GetService("Players").LocalPlayer

-- Tạo file config riêng cho mỗi người chơi
local ConfigFile = "mygui_config_" .. LocalPlayer.UserId .. ".json"

-- Cấu trúc config mặc định
local Config = {
    Buttons = {}, -- Lưu keybind + trạng thái của từng chức năng
    GuiPosition = {X = 0, Y = 0}, -- Vị trí GUI
    GuiVisible = true, -- Trạng thái hiện/ẩn menu
    ESPEnabled = false,
    SpeedEnabled = false,
    FlyEnabled = false,
    AimbotEnabled = false,
    FullbrightEnabled = false,
    NoclipEnabled = false,
    ShiftAmount = 0.5,
    SelectedPlayers = {},
    FlySpeed = 35,
    SpeedAmount = 20,
    infiniteJumpEnabled = false,
    clickTpEnabled = false,
    checkKOAimbot = false,
    CustomPing = nil
}

-- Hàm lưu config
local function SaveSettings()
    local success, err = pcall(function()
        writefile(ConfigFile, HttpService:JSONEncode(Config))
    end)
    if not success then
        warn("[SaveSettings] Lỗi lưu config:", err)
    end
end

-- Hàm load config
local function LoadSettings()
    if isfile(ConfigFile) then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile(ConfigFile))
        end)
        if success and type(data) == "table" then
            -- Gộp dữ liệu load vào Config hiện tại
            for k, v in pairs(data) do
                Config[k] = v
            end
        else
            warn("[LoadSettings] Lỗi đọc config:", data)
        end
    else
        -- Nếu chưa có file thì tạo mới
        SaveSettings()
    end
end

-- Load config ngay khi script chạy
LoadSettings()

local autoSelect = false
local tbEnabled = false
local fovRadius = 20
local Player = nil
local camera = Workspace.CurrentCamera
local camConnection
local clickTpTool = nil
local savedWaypoint = nil
local noclipConnection = nil
local autoKillEnabled = false
local autoKillLoop = nil


-- Biến lưu trạng thái Lighting cũ cho Fullbright
local oldLighting = {
    Brightness = Lighting.Brightness,
    GlobalShadows = Lighting.GlobalShadows,
    FogEnd = Lighting.FogEnd,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    ClockTime = Lighting.ClockTime
}

-- Tạo hiệu ứng mờ nền
local blur = Instance.new("BlurEffect")
blur.Size = 20
blur.Parent = Lighting

-- Tạo GUI intro
local introGui = Instance.new("ScreenGui")
introGui.Name = "VhuyIntroGui"
introGui.IgnoreGuiInset = true
introGui.ResetOnSpawn = false
introGui.DisplayOrder = 99999
introGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local bg = Instance.new("Frame")
bg.Size = UDim2.new(1, 0, 1, 0)
bg.BackgroundColor3 = Color3.new(0, 0, 0)
bg.BackgroundTransparency = 1
bg.Parent = introGui

local title = Instance.new("TextLabel")
title.AnchorPoint = Vector2.new(0.5, 0.5)
title.Position = UDim2.new(0.5, 0, 0.5, 0)
title.Size = UDim2.new(0, 400, 0, 120)
title.Text = "DhuyxDtuyen"
title.Font = Enum.Font.GothamBlack
title.TextColor3 = Color3.fromRGB(255, 179, 186)
title.TextScaled = true
title.TextTransparency = 1
title.BackgroundTransparency = 1
title.Parent = introGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = title

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 179, 186)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 100, 100))
}
gradient.Rotation = 45
gradient.Parent = title

-- Hiệu ứng fade in
TweenService:Create(title, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 0}):Play()
TweenService:Create(bg, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 0.4}):Play()

-- Hiệu ứng fade out
task.delay(4, function()
    TweenService:Create(title, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 1}):Play()
    TweenService:Create(bg, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
    task.delay(1.5, function()
        introGui:Destroy()
        blur:Destroy()
    end)
end)

- === Nút Select Target giống Cactus ===
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local selectGui = Instance.new("ScreenGui")
selectGui.Name = "SelectTargetGui"
selectGui.ResetOnSpawn = false
selectGui.Parent = CoreGui

local selectBtn = Instance.new("TextButton")
selectBtn.Size = UDim2.new(0, 110, 0, 35)
selectBtn.Position = UDim2.new(0, 300, 0, 200)
selectBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 200)
selectBtn.Text = "Select Target"
selectBtn.Font = Enum.Font.GothamBold
selectBtn.TextSize = 14
selectBtn.TextColor3 = Color3.new(0,0,0)
selectBtn.Parent = selectGui
Instance.new("UICorner", selectBtn).CornerRadius = UDim.new(0, 8)

-- Kéo di chuyển nút
local dragging, dragStart, startPos
selectBtn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = selectBtn.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        selectBtn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Hàm chọn player giống Cactus (gần chuột nhất trong FOV)
local FOV_RADIUS = 150 -- giống Cactus mặc định
local function GetClosestValidPlayer()
    local closest, shortestDist = nil, math.huge
    local mousePos = UserInputService:GetMouseLocation()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = plr.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                local distFromMouse = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if distFromMouse <= FOV_RADIUS and distFromMouse < shortestDist then
                    shortestDist = distFromMouse
                    closest = plr
                end
            end
        end
    end
    return closest
end

-- Xử lý khi bấm nút
selectBtn.MouseButton1Click:Connect(function()
    local target = GetClosestValidPlayer()
    if target then
        if Config.SelectedPlayers[target.Name] then
            Config.SelectedPlayers[target.Name] = nil
            game.StarterGui:SetCore("SendNotification", {
                Title = "Select Target",
                Text = "Bỏ chọn: " .. target.Name,
                Duration = 2
            })
        else
            Config.SelectedPlayers[target.Name] = true
            game.StarterGui:SetCore("SendNotification", {
                Title = "Select Target",
                Text = "Đã chọn: " .. target.Name,
                Duration = 2
            })
        end
        SaveSettings()
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Select Target",
            Text = "Không tìm thấy mục tiêu trong FOV",
            Duration = 2
        })
    end
end)

-- Hàm dịch chuyển đến người gần nhất
local function TeleportToClosest()
    local closestKO, closestAlive = nil, nil
    local minDistKO, minDistAlive = math.huge, math.huge
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position

    if not myPos then return end

    for name, selected in pairs(Config.SelectedPlayers) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local pos = plr.Character.HumanoidRootPart.Position
                local dist = (myPos - pos).Magnitude
                if dist < minDistAlive then
                    closestAlive = plr
                    minDistAlive = dist
                end
            end
        end
    end

    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local oldPos = root.CFrame

    if closestKO then
        local torso = closestKO.Character:FindFirstChild("Torso") or closestKO.Character:FindFirstChild("HumanoidRootPart")
        if torso then
            root.CFrame = torso.CFrame
            task.wait(0.2)
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(1.5)
        end
    elseif closestAlive then
        local torso = closestAlive.Character:FindFirstChild("HumanoidRootPart") or closestAlive.Character:FindFirstChild("HumanoidRootPart")
        if torso then
            root.CFrame = torso.CFrame + Vector3.new(0, 30, 0)
        end
    end
end

-- GUI chính
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "DhuyxMenu"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = PlayerGui

local MenuFrame = Instance.new("Frame")
MenuFrame.Size = UDim2.new(0, 400, 0, 250)
MenuFrame.Position = UDim2.new(0.05, 0, 0.2, 0)
MenuFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
MenuFrame.BackgroundTransparency = 0.1
MenuFrame.Active = true
MenuFrame.Draggable = true
MenuFrame.Parent = ScreenGui
Instance.new("UICorner", MenuFrame).CornerRadius = UDim.new(0, 12)

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 179, 186)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 255))
}
gradient.Rotation = 45
gradient.Parent = MenuFrame

local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(255, 255, 255)
stroke.Transparency = 0.3
stroke.Parent = MenuFrame

-- Nút Toggle Show/Hide
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 70, 0, 30)
ToggleButton.Position = UDim2.new(0, 20, 0, 240)
ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 179, 186)
ToggleButton.Text = "SHOW"
ToggleButton.TextColor3 = Color3.new(0, 0, 0)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.TextSize = 16
ToggleButton.Active = true
ToggleButton.Draggable = true
ToggleButton.Parent = ScreenGui
Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 10)

local toggleGradient = Instance.new("UIGradient")
toggleGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 179, 186)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 100, 100))
}
toggleGradient.Parent = ToggleButton

-- Hiệu ứng hover/click
local function animateButton(btn)
    btn.MouseEnter:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(255, 200, 200)}):Play()
    end)
    btn.MouseLeave:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(255, 179, 186)}):Play()
    end)
    btn.MouseButton1Click:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.1), {Size = btn.Size + UDim2.new(0, 5, 0, 5)}):Play()
        task.wait(0.1)
        TweenService:Create(btn, TweenInfo.new(0.1), {Size = btn.Size - UDim2.new(0, 5, 0, 5)}):Play()
    end)
end
animateButton(ToggleButton)

ToggleButton.MouseButton1Click:Connect(function()
    local targetSize = MenuFrame.Visible and UDim2.new(0, 0, 0, 0) or UDim2.new(0, 300, 0, 250)
    local tween = TweenService:Create(MenuFrame, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = targetSize})
    if not MenuFrame.Visible then
        MenuFrame.Visible = true
        tween:Play()
    else
        tween:Play()
        tween.Completed:Wait()
        MenuFrame.Visible = false
    end
    ToggleButton.Text = MenuFrame.Visible and "HIDE" or "SHOW"
end)

-- Tiêu đề & Ping/FPS/Clock
local MenuTitle = Instance.new("TextLabel")
MenuTitle.Size = UDim2.new(1, 0, 0, 30)
MenuTitle.BackgroundTransparency = 1
MenuTitle.Text = "DhuyxDtuyen"
MenuTitle.TextColor3 = Color3.fromRGB(255, 179, 186)
MenuTitle.Font = Enum.Font.GothamBlack
MenuTitle.TextSize = 18
MenuTitle.Parent = MenuFrame

local PingClock = Instance.new("TextLabel")
PingClock.Size = UDim2.new(0, 200, 0, 25)
PingClock.Position = UDim2.new(0, 5, 0, -30)
PingClock.BackgroundTransparency = 1
PingClock.TextColor3 = Color3.fromRGB(255, 255, 255)
PingClock.Font = Enum.Font.Gotham
PingClock.TextSize = 14
PingClock.Parent = MenuTitle

task.spawn(function()
    while task.wait(1) do
        local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local fps = math.floor(1 / RunService.RenderStepped:Wait())
        local timeStr = os.date("%H:%M")
        PingClock.Text = string.format("Ping: %d ms | FPS: %d | %s", ping, fps, timeStr)
    end
end)

local PingBox = Instance.new("TextBox")
PingBox.Size = UDim2.new(0, 80, 0, 25)
PingBox.Position = UDim2.new(1, -85, 0, 2)
PingBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PingBox.BackgroundTransparency = 0.2
PingBox.TextColor3 = Color3.fromRGB(0, 0, 0)
PingBox.TextSize = 14
PingBox.Font = Enum.Font.Gotham
PingBox.PlaceholderText = "Ping (ms)"
PingBox.Text = ""
PingBox.ClearTextOnFocus = false
PingBox.Parent = MenuTitle
Instance.new("UICorner", PingBox).CornerRadius = UDim.new(0, 6)

PingBox:GetPropertyChangedSignal("Text"):Connect(function()
    local input = tonumber(PingBox.Text)
    if input and input >= 0 then
        Config.CustomPing = math.clamp(input, 10, 1000)
    else
        Config.CustomPing = nil
    end
    SaveSettings()
end)

-- Tạo 3 trang
local currentPage = 1

local Page1 = Instance.new("Frame")
Page1.Size = UDim2.new(1, 0, 1, -70)
Page1.Position = UDim2.new(0, 0, 0, 30)
Page1.BackgroundTransparency = 1
Page1.Parent = MenuFrame

-- Frame danh sách người chơi cho trang 1
local PlayerListFrame = Instance.new("Frame")
PlayerListFrame.Size = UDim2.new(0.5, -5, 1, -20)
PlayerListFrame.Position = UDim2.new(0, 5, 0, 10)
PlayerListFrame.BackgroundTransparency = 1
PlayerListFrame.Parent = Page1

local PlayerList = Instance.new("ScrollingFrame")
PlayerList.Size = UDim2.new(1, 0, 1, 0)
PlayerList.CanvasSize = UDim2.new(0, 0, 0, 0)
PlayerList.ScrollBarThickness = 4
PlayerList.BackgroundTransparency = 1
PlayerList.Parent = PlayerListFrame

local UIListLayout = Instance.new("UIListLayout")
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 4)
UIListLayout.Parent = PlayerList
UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    PlayerList.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y)
end)

-- Frame nút chức năng cho trang 1
local ButtonFrame1 = Instance.new("ScrollingFrame")
ButtonFrame1.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame1.Position = UDim2.new(0.5, 0, 0, 10)
ButtonFrame1.BackgroundTransparency = 1
ButtonFrame1.ScrollBarThickness = 4
ButtonFrame1.CanvasSize = UDim2.new(0, 0, 0, 0)
ButtonFrame1.Parent = Page1

local ButtonLayout1 = Instance.new("UIListLayout")
ButtonLayout1.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout1.Padding = UDim.new(0, 6)
ButtonLayout1.Parent = ButtonFrame1
ButtonLayout1:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame1.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout1.AbsoluteContentSize.Y)
end)

local Page2 = Instance.new("Frame")
Page2.Size = UDim2.new(1, 0, 1, -70)
Page2.Position = UDim2.new(0, 0, 0, 30)
Page2.BackgroundTransparency = 1
Page2.Visible = false
Page2.Parent = MenuFrame

-- Frame nút chức năng trái cho trang 2
local ButtonFrame2Left = Instance.new("ScrollingFrame")
ButtonFrame2Left.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame2Left.Position = UDim2.new(0, 5, 0, 10)
ButtonFrame2Left.BackgroundTransparency = 1
ButtonFrame2Left.ScrollBarThickness = 4
ButtonFrame2Left.CanvasSize = UDim2.new(0, 0, 0, 0)
ButtonFrame2Left.Parent = Page2

local ButtonLayout2Left = Instance.new("UIListLayout")
ButtonLayout2Left.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout2Left.Padding = UDim.new(0, 6)
ButtonLayout2Left.Parent = ButtonFrame2Left
ButtonLayout2Left:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame2Left.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout2Left.AbsoluteContentSize.Y)
end)

-- Frame nút chức năng phải cho trang 2
local ButtonFrame2Right = Instance.new("ScrollingFrame")
ButtonFrame2Right.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame2Right.Position = UDim2.new(0.5, 0, 0, 10)
ButtonFrame2Right.BackgroundTransparency = 1
ButtonFrame2Right.ScrollBarThickness = 4
ButtonFrame2Right.CanvasSize = UDim2.new(0, 0, 0, 0)
ButtonFrame2Right.Parent = Page2

local ButtonLayout2Right = Instance.new("UIListLayout")
ButtonLayout2Right.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout2Right.Padding = UDim.new(0, 6)
ButtonLayout2Right.Parent = ButtonFrame2Right
ButtonLayout2Right:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame2Right.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout2Right.AbsoluteContentSize.Y)
end)

local Page3 = Instance.new("Frame")
Page3.Size = UDim2.new(1, 0, 1, -70)
Page3.Position = UDim2.new(0, 0, 0, 30)
Page3.BackgroundTransparency = 1
Page3.Visible = false
Page3.Parent = MenuFrame

local ScriptHubScroll = Instance.new("ScrollingFrame")
ScriptHubScroll.Size = UDim2.new(1, -10, 1, -50)
ScriptHubScroll.Position = UDim2.new(0, 5, 0, 5)
ScriptHubScroll.BackgroundTransparency = 1
ScriptHubScroll.ScrollBarThickness = 6
ScriptHubScroll.ScrollingDirection = Enum.ScrollingDirection.Y
ScriptHubScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
ScriptHubScroll.Parent = Page3

local ScriptListLayout = Instance.new("UIListLayout")
ScriptListLayout.SortOrder = Enum.SortOrder.LayoutOrder
ScriptListLayout.Padding = UDim.new(0, 6)
ScriptListLayout.FillDirection = Enum.FillDirection.Vertical
ScriptListLayout.Parent = ScriptHubScroll

ScriptListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ScriptHubScroll.CanvasSize = UDim2.new(0, 0, 0, ScriptListLayout.AbsoluteContentSize.Y)
end)

local function CreateScriptItem(name, url)
    local itemFrame = Instance.new("Frame")
    itemFrame.Size = UDim2.new(1, 0, 0, 35)
    itemFrame.BackgroundTransparency = 0.2
    itemFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    itemFrame.Parent = ScriptHubScroll
    Instance.new("UICorner", itemFrame).CornerRadius = UDim.new(0, 6)

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(0.7, 0, 1, 0)
    nameLabel.Position = UDim2.new(0, 5, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = name
    nameLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Parent = itemFrame

    local runBtn = Instance.new("TextButton")
    runBtn.Size = UDim2.new(0.3, -10, 1, -4)
    runBtn.Position = UDim2.new(0.7, 5, 0, 2)
    runBtn.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
    runBtn.Text = "Run"
    runBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
    runBtn.TextSize = 16
    runBtn.Font = Enum.Font.GothamBold
    runBtn.Parent = itemFrame
    Instance.new("UICorner", runBtn).CornerRadius = UDim.new(0, 6)
    animateButton(runBtn)

    runBtn.MouseButton1Click:Connect(function()
        loadstring(game:HttpGet(url))()
    end)

    return itemFrame
end

CreateScriptItem("Evade", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/evade")
CreateScriptItem("Murder Mystery 2", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/mm2")
CreateScriptItem("Blade Ball", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/Bladeball")
CreateScriptItem("Doors", "https://raw.githubusercontent.com/DarkDoorsKing/Project/main/Doors.lua")
CreateScriptItem("Emote", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/emote")

local PageButtons = Instance.new("Frame")
PageButtons.Size = UDim2.new(1, 0, 0, 35)
PageButtons.Position = UDim2.new(0, 0, 1, -35)
PageButtons.BackgroundTransparency = 1
PageButtons.Parent = MenuFrame

local Btn1 = Instance.new("TextButton")
Btn1.Size = UDim2.new(1/3, -2, 1, 0)
Btn1.Position = UDim2.new(0, 0, 0, 0)
Btn1.Text = "Da Hood"
Btn1.BackgroundColor3 = Color3.fromRGB(255, 179, 186)
Btn1.TextColor3 = Color3.fromRGB(0, 0, 0)
Btn1.Font = Enum.Font.GothamBold
Btn1.TextSize = 16
Instance.new("UICorner", Btn1).CornerRadius = UDim.new(0, 6)
Btn1.Parent = PageButtons
animateButton(Btn1)

local Btn2 = Instance.new("TextButton")
Btn2.Size = UDim2.new(1/3, -2, 1, 0)
Btn2.Position = UDim2.new(1/3, 2, 0, 0)
Btn2.Text = "Universal"
Btn2.BackgroundColor3 = Color3.fromRGB(255, 179, 186)
Btn2.TextColor3 = Color3.fromRGB(0, 0, 0)
Btn2.Font = Enum.Font.GothamBold
Btn2.TextSize = 16
Instance.new("UICorner", Btn2).CornerRadius = UDim.new(0, 6)
Btn2.Parent = PageButtons
animateButton(Btn2)

local Btn3 = Instance.new("TextButton")
Btn3.Size = UDim2.new(1/3, -2, 1, 0)
Btn3.Position = UDim2.new(2/3, 2, 0, 0)
Btn3.Text = "Script Other"
Btn3.BackgroundColor3 = Color3.fromRGB(255, 179, 186)
Btn3.TextColor3 = Color3.fromRGB(0, 0, 0)
Btn3.Font = Enum.Font.GothamBold
Btn3.TextSize = 16
Instance.new("UICorner", Btn3).CornerRadius = UDim.new(0, 6)
Btn3.Parent = PageButtons
animateButton(Btn3)

local function ShowPage(page)
    Page1.Visible = (page == 1)
    Page2.Visible = (page == 2)
    Page3.Visible = (page == 3)
end

Btn1.MouseButton1Click:Connect(function()
    ShowPage(1)
end)
Btn2.MouseButton1Click:Connect(function()
    ShowPage(2)
end)
Btn3.MouseButton1Click:Connect(function()
    ShowPage(3)
end)

local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

local ButtonsMap = {} -- Map tên chức năng -> callback
local ActiveScreenButtons = {} -- Lưu nút ngoài màn hình để quản lý xoá / tạo

local function CreateButton(parent, name, callback)
    ButtonsMap[name] = callback

    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(1, -10, 0, 30)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.Parent = parent

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0.7, -5, 1, 0)
    button.BackgroundColor3 = Color3.fromRGB(255, 179, 186)
    button.BackgroundTransparency = 0.2
    button.TextColor3 = Color3.fromRGB(0, 0, 0)
    button.TextSize = 14
    button.Font = Enum.Font.Gotham
    button.Text = name
    button.Parent = buttonFrame
    Instance.new("UICorner", button).CornerRadius = UDim.new(0, 6)
    animateButton(button)
    button.MouseButton1Click:Connect(callback)

    local keyBox = Instance.new("TextBox")
    keyBox.Size = UDim2.new(0.3, 0, 1, 0)
    keyBox.Position = UDim2.new(0.7, 5, 0, 0)
    keyBox.BackgroundColor3 = Color3.fromRGB(230, 230, 230)
    keyBox.PlaceholderText = "Key"
    keyBox.Text = Config.Buttons[name] and Config.Buttons[name].Raw or "" -- Giữ nguyên lần sau load
    keyBox.TextColor3 = Color3.fromRGB(0, 0, 0)
    keyBox.TextSize = 14
    keyBox.Font = Enum.Font.Gotham
    keyBox.ClearTextOnFocus = false
    keyBox.Parent = buttonFrame
    Instance.new("UICorner", keyBox).CornerRadius = UDim.new(0, 6)

    -- Hàm tạo nút ngoài màn hình
    local function createScreenButton()
        if ActiveScreenButtons[name] then return end
        local screenGui = Instance.new("ScreenGui")
        screenGui.IgnoreGuiInset = true
        screenGui.ResetOnSpawn = false
        screenGui.Parent = CoreGui

        local screenBtn = Instance.new("TextButton")
        screenBtn.Size = UDim2.new(0, 70, 0, 30)
        screenBtn.Position = UDim2.new(0, 100, 0, 300)
        screenBtn.BackgroundColor3 = Color3.fromRGB(200, 200, 255)
        screenBtn.Text = name
        screenBtn.TextColor3 = Color3.new(0, 0, 0)
        screenBtn.TextSize = 10
        screenBtn.Font = Enum.Font.GothamBold
        screenBtn.Parent = screenGui
        Instance.new("UICorner", screenBtn).CornerRadius = UDim.new(0, 6)

        -- Kéo di chuyển
        local dragging, dragStart, startPos
        screenBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = screenBtn.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                screenBtn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)

        screenBtn.MouseButton1Click:Connect(callback)
        ActiveScreenButtons[name] = screenGui
    end

    -- Hàm xoá nút ngoài màn hình
    local function removeScreenButton()
        if ActiveScreenButtons[name] then
            ActiveScreenButtons[name]:Destroy()
            ActiveScreenButtons[name] = nil
        end
    end

    -- Cập nhật khi text thay đổi
    local function updateKeyBind()
        local raw = keyBox.Text
        local upper = raw:upper()

        Config.Buttons[name] = { Raw = raw } -- lưu raw text
        if upper == "" then
            Config.Buttons[name].Key = nil
            removeScreenButton()
        elseif upper == "BUTTON" then
            Config.Buttons[name].Key = nil
            createScreenButton()
        elseif Enum.KeyCode[upper] then
            Config.Buttons[name].Key = upper
            removeScreenButton()
        else
            -- Không hợp lệ
            Config.Buttons[name].Key = nil
            removeScreenButton()
        end
        SaveSettings()
    end

    keyBox:GetPropertyChangedSignal("Text"):Connect(updateKeyBind)

    -- Khởi động: nếu là "button" thì tạo nút
    if (Config.Buttons[name] and Config.Buttons[name].Raw and Config.Buttons[name].Raw:upper() == "BUTTON") then
        createScreenButton()
    end

    return button -- giữ lại để dùng bên ngoài như espButton = CreateButton(...)
end


-- Lắng phím nhấn
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    for funcName, data in pairs(Config.Buttons) do
        if data.Key and input.KeyCode == Enum.KeyCode[data.Key] then
            if ButtonsMap[funcName] then
                ButtonsMap[funcName]()
            end
        end
    end
end)


-- Nút cho trang 1
espButton = CreateButton(ButtonFrame1, "ESP: OFF", function()
    Config.ESPEnabled = not Config.ESPEnabled
    sendNotification("ESP", Config.ESPEnabled and "ON" or "OFF")
    espButton.Text = "ESP: " .. (Config.ESPEnabled and "ON" or "OFF")
    SaveSettings()
end)

speedButton = CreateButton(ButtonFrame1, "Speed: OFF", function()
    Config.SpeedEnabled = not Config.SpeedEnabled
    sendNotification("SPEED", Config.SpeedEnabled and "ON" or "OFF")
    speedButton.Text = "Speed: " .. (Config.SpeedEnabled and "ON" or "OFF")
    SaveSettings()
end)

flyButton = CreateButton(ButtonFrame1, "Fly: OFF", function()
    Config.FlyEnabled = not Config.FlyEnabled
    sendNotification("FLY", Config.FlyEnabled and "ON" or "OFF")
    flyButton.Text = "Fly: " .. (Config.FlyEnabled and "ON" or "OFF")
    SaveSettings()
end)

aimbotButton = CreateButton(ButtonFrame1, "Aimbot: OFF", function()
    Config.AimbotEnabled = not Config.AimbotEnabled
    sendNotification("AIMBOT", Config.AimbotEnabled and "ON" or "OFF")
    aimbotButton.Text = "Aimbot: " .. (Config.AimbotEnabled and "ON" or "OFF")
    SaveSettings()
end)

checkKOAimbotButton = CreateButton(ButtonFrame1, "Check K.O Aimbot: OFF", function()
    Config.checkKOAimbot = not Config.checkKOAimbot
    sendNotification("CHECK K.O AIMBOT", Config.checkKOAimbot and "ON" or "OFF")
    checkKOAimbotButton.Text = "Check K.O Aimbot: " .. (Config.checkKOAimbot and "ON" or "OFF")
    SaveSettings()
end)

-- ======= CONFIG MẶC ĐỊNH =======
Config.AntiLockEnabled = Config.AntiLockEnabled or false
Config.AntiLockType = Config.AntiLockType or "Behind"
Config.AutoStompEnabled = Config.AutoStompEnabled or false

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local antiLockModes = {
    Behind = true, Down = true, ForWard = true,
    Left = true, One = true, Right = true,
    Up = true, Zero = true
}

antiLockButton = CreateButton(ButtonFrame1, "AntiLock: " .. (Config.AntiLockEnabled and "ON" or "OFF"), function()
    Config.AntiLockEnabled = not Config.AntiLockEnabled
    antiLockButton.Text = "AntiLock: " .. (Config.AntiLockEnabled and "ON" or "OFF")
    sendNotification("AntiLock", Config.AntiLockEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Ô nhập mode cho AntiLock
local modeBox = Instance.new("TextBox")
modeBox.Size = UDim2.new(1, 0, 0, 20)
modeBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
modeBox.TextColor3 = Color3.new(1, 1, 1)
modeBox.Font = Enum.Font.GothamBold
modeBox.TextSize = 12
modeBox.ClearTextOnFocus = false
modeBox.PlaceholderText = "Enter mode (default Behind)"
modeBox.Text = Config.AntiLockType
Instance.new("UICorner", modeBox).CornerRadius = UDim.new(0, 4)
modeBox.Parent = ButtonFrame1

modeBox.FocusLost:Connect(function()
    local input = modeBox.Text
    if input == "" then
        Config.AntiLockType = "Behind"
    elseif antiLockModes[input] then
        Config.AntiLockType = input
    else
        sendNotification("AntiLock", "Invalid mode! Keeping: " .. Config.AntiLockType)
        modeBox.Text = Config.AntiLockType
        return
    end
    sendNotification("AntiLock", "Type set to: " .. Config.AntiLockType)
    SaveSettings()
end)

-- ======= LOGIC ANTILOCK =======
if _G.__vhuyhub_antilock_conn then
    _G.__vhuyhub_antilock_conn:Disconnect()
end

_G.__vhuyhub_antilock_conn = RunService.Heartbeat:Connect(function()
    if not Config.AntiLockEnabled then return end

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local dir = Vector3.new(0, 0, -1) -- default Behind
    local t = Config.AntiLockType
    if     t == "Behind"  then dir = Vector3.new(0,  0, -1)
    elseif t == "Down"    then dir = Vector3.new(0, -1,  0)
    elseif t == "ForWard" then dir = Vector3.new(0,  0,  1)
    elseif t == "Left"    then dir = Vector3.new(-1, 0,  0)
    elseif t == "One"     then dir = Vector3.new(1,  1,  1)
    elseif t == "Right"   then dir = Vector3.new(1,  0,  0)
    elseif t == "Up"      then dir = Vector3.new(0,  1,  0)
    elseif t == "Zero"    then dir = Vector3.new(0,  0,  0)
    end

    local oldVel = hrp.Velocity
    hrp.Velocity = dir * (2^16)
    RunService.RenderStepped:Wait()
    if hrp and hrp.Parent then
        hrp.Velocity = oldVel
    end
end)

autoStompButton = CreateButton(ButtonFrame1, "AutoStomp: " .. (Config.AutoStompEnabled and "ON" or "OFF"), function()
    Config.AutoStompEnabled = not Config.AutoStompEnabled
    autoStompButton.Text = "AutoStomp: " .. (Config.AutoStompEnabled and "ON" or "OFF")
    sendNotification("AutoStomp", Config.AutoStompEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- ======= LOGIC AUTOSTOMP (Check K.O) =======
local function isKO(plr)
    local char = plr and plr.Character
    local be = char and char:FindFirstChild("BodyEffects")
    return be and be:FindFirstChild("K.O") and be["K.O"].Value == true
end

local function getKOSelected()
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and isKO(plr) then
                return plr
            end
        end
    end
    return nil
end

local function stompTarget(target)  
    local myChar = LocalPlayer.Character  
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")  
    local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")  
    if not myHRP or not myHum then return end  
  
    local lowerTorso = target.Character and target.Character:FindFirstChild("LowerTorso")  
    if not lowerTorso then return end  
  
    local oldCFrame = myHRP.CFrame  
  
    -- Dừng mọi hành động  
     
  
    -- TP tới target  
    myHRP.CFrame = lowerTorso.CFrame + Vector3.new(0, 2, 0)  
  
    -- Giả lập bấm E  
    keypress(Enum.KeyCode.E)  
    task.wait(0.05)  
    keyrelease(Enum.KeyCode.E)  
  
    -- Chờ 1.5 giây  
    task.wait(1.5)  
  
    -- Trả về vị trí cũ  
    myHRP.CFrame = oldCFrame 
end

-- AutoStomp + Auto disable/enable AntiLock
local pausedAntiLock = false
RunService.Heartbeat:Connect(function()
    if not Config.AutoStompEnabled then return end

    local target = getKOSelected()
    if target then
        -- Tắt AntiLock nếu đang bật
        if Config.AntiLockEnabled then
            pausedAntiLock = true
            Config.AntiLockEnabled = false
            antiLockButton.Text = "AntiLock: OFF"
            sendNotification("AntiLock", "Disabled for AutoStomp")
        end
        stompTarget(target)
    else
        -- Bật lại AntiLock nếu trước đó tắt tạm
        if pausedAntiLock then
            Config.AntiLockEnabled = true
            antiLockButton.Text = "AntiLock: ON"
            sendNotification("AntiLock", "Re-enabled after AutoStomp")
            pausedAntiLock = false
        end
    end
end)

-- ==== CONFIG ====
Config.AutoShiftLockEnabled = Config.AutoShiftLockEnabled or false



-- ==== CONFIG ====
if Config.LookAtEnabled == nil then Config.LookAtEnabled = false end

-- ==== UTILS ====
local function getMyHumanoid()
    local char = LocalPlayer.Character
    if not char then return nil,nil,nil end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    return char, hum, hrp
end

local function getClosestSelected()
    local _, _, myHRP = getMyHumanoid()
    if not myHRP then return nil end
    local myPos = myHRP.Position
    local closest, dmin = nil, math.huge

    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local chr = plr and plr.Character
            local thrp = chr and chr:FindFirstChild("HumanoidRootPart")
            if thrp then
                local d = (myPos - thrp.Position).Magnitude
                if d < dmin then closest, dmin = plr, d end
            end
        end
    end
    return closest
end

Config.ResolverEnabled = Config.ResolverEnabled or false

-- Hàm lấy player gần nhất trong danh sách SelectedPlayers
local function getClosestSelected()
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local closest, minDist
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local hrp = plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (myHRP.Position - hrp.Position).Magnitude
                if not minDist or dist < minDist then
                    closest, minDist = plr, dist
                end
            end
        end
    end
    return closest
end

-- Nút Resolver mới
resolverButton = CreateButton(ButtonFrame1, "Resolver: OFF", function()
    Config.ResolverEnabled = not Config.ResolverEnabled
    resolverButton.Text = "Resolver: " .. (Config.ResolverEnabled and "ON" or "OFF")
    sendNotification("Resolver", Config.ResolverEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Logic Resolver mới
if _G.__custom_resolver_conn then
    _G.__custom_resolver_conn:Disconnect()
end

_G.__custom_resolver_conn = RunService.Heartbeat:Connect(function()
    if not Config.ResolverEnabled then return end

    local target = getClosestSelected()
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = target.Character.HumanoidRootPart
        -- Xử lý velocity: khử trục Y
        hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
        hrp.AssemblyLinearVelocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
    end
end)

-- TP Bullet Button
tpBulletEnabled = false
tpBulletButton = CreateButton(ButtonFrame1, "TP Bullet: OFF", function()
    tpBulletEnabled = not tpBulletEnabled
    tpBulletButton.Text = "TP Bullet: " .. (tpBulletEnabled and "ON" or "OFF")
    sendNotification("TP Bullet", tpBulletEnabled and "Enabled" or "Disabled")

    if tpBulletEnabled then
        startTpBullet()
    else
        stopTpBullet()
    end
    SaveSettings()
end)

-- ===================== TP BULLET LOGIC =====================
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerCharacter = player.Character or player.CharacterAdded:Wait()
local playerHumanoidRootPart = playerCharacter:WaitForChild("HumanoidRootPart")
local playerCamera = Workspace.CurrentCamera

local TargetedPlayer, TargetedPlayerCharacter, TargetedPlayerHumanoidRootPart, TargetedPlayerAimPart

getgenv().TpBullet = {
    Settings = {
        AimPart = "HumanoidRootPart",
        Prediction = { Enabled = true, Horizontal = 0.147591, Vertical = 0.147591 },
        },
    }
}


-- Lấy người chơi gần nhất theo khoảng cách 3D, không cần FOV
local function GetClosestPlayer()
    local closest, shortest = nil, math.huge
    local myPos = playerHumanoidRootPart.Position

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (plr.Character.HumanoidRootPart.Position - myPos).Magnitude
            if dist < shortest then
                shortest = dist
                closest = plr
            end
        end
    end
    return closest
end

-- Hook storage
local RawMetaTable, OldNameCall

function startTpBullet()
    -- Chọn target
    TargetedPlayer = GetClosestPlayer()
    if TargetedPlayer then
        TargetedPlayerCharacter = TargetedPlayer.Character or TargetedPlayer.CharacterAdded:Wait()
        TargetedPlayerHumanoidRootPart = TargetedPlayerCharacter:WaitForChild("HumanoidRootPart")
        TargetedPlayerAimPart = TargetedPlayerCharacter:WaitForChild(TpBullet.Settings.AimPart)
        Notification("Found Target", "Target: " .. TargetedPlayer.DisplayName)
    else
        Notification("No Target Found", "No Players Found Within FOV Circle.")
        tpBulletEnabled = false
        tpBulletButton.Text = "TP Bullet: OFF"
        return
    end

    -- Hook namecall
    RawMetaTable = getrawmetatable(game)
    OldNameCall = RawMetaTable.__namecall
    setreadonly(RawMetaTable, false)
    RawMetaTable.__namecall = newcclosure(function(self, ...)
        local args = {...}
        if tpBulletEnabled and TargetedPlayer and TargetedPlayerAimPart
           and string.lower(self.Name) == "mainevent"
           and getnamecallmethod() == "FireServer"
           and (args[1] == "UpdateMousePos" or args[1] == "MOUSE") then
            args[2] = TargetedPlayerAimPart.Position +
                Vector3.new(TargetedPlayerAimPart.Velocity.X * TpBullet.Settings.Prediction.Horizontal,
                            TargetedPlayerAimPart.Velocity.Y * TpBullet.Settings.Prediction.Vertical,
                            0)
            return OldNameCall(self, unpack(args))
        end
        return OldNameCall(self, ...)
    end)
end

function stopTpBullet()
    TargetedPlayer, TargetedPlayerCharacter, TargetedPlayerHumanoidRootPart, TargetedPlayerAimPart = nil, nil, nil, nil
    if RawMetaTable and OldNameCall then
        RawMetaTable.__namecall = OldNameCall
        setreadonly(RawMetaTable, true)
    end
end

local lastTargetName, lastNotify = nil, 0

lookAtBtnRef = CreateButton(ButtonFrame1, "Look At: " .. (Config.LookAtEnabled and "ON" or "OFF"), function()
    Config.LookAtEnabled = not Config.LookAtEnabled
    lookAtBtnRef.Text = "Look At: " .. (Config.LookAtEnabled and "ON" or "OFF")

    -- đồng bộ AutoRotate như catus (khi enable thì tắt autorotate để mình điều khiển hướng)
    local _, hum = getMyHumanoid()
    if hum then hum.AutoRotate = not Config.LookAtEnabled end

    if not Config.LookAtEnabled then
        lastTargetName = nil
        lastNotify = 0
    end
    SaveSettings()
end)

-- ==== LOOP XOAY NHÂN VẬT NHÌN TARGET (theo logic catus: xoay HRP) ====
RunService.RenderStepped:Connect(function()
    if not Config.LookAtEnabled then return end

    local char, hum, hrp = getMyHumanoid()
    if not (hum and hrp) then return end

    -- đảm bảo autorotate tắt khi đang bật look-at
    if hum.AutoRotate ~= false then hum.AutoRotate = false end

    local targetPlr = getClosestSelected()
    if not targetPlr then return end

    local thrp = targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart")
    if not thrp then return end

    -- CHỈ xoay yaw như catus (không ngẩng cúi), giữ nguyên cao độ
    local myPos = hrp.Position
    local tPos = thrp.Position
    local facePos = Vector3.new(tPos.X, myPos.Y, tPos.Z)

    -- set hướng: dùng lookAt + lerp nhẹ để mượt (giống feel của catus)
    local desired = CFrame.lookAt(myPos, facePos)
    hrp.CFrame = hrp.CFrame:Lerp(desired, 0.35)

    -- Thông báo khi đổi target (anti-spam)
    if targetPlr.Name ~= lastTargetName then
        lastTargetName = targetPlr.Name
        local now = tick()
        if now - lastNotify > 0.25 then
            sendNotification("Look At", "Đang hướng vào: " .. lastTargetName)
            lastNotify = now
        end
    end
end)

-- (tuỳ chọn) khi nhân vật respawn, khôi phục AutoRotate đúng trạng thái
LocalPlayer.CharacterAdded:Connect(function()
    task.defer(function()
        local _, hum = getMyHumanoid()
        if hum then hum.AutoRotate = not Config.LookAtEnabled end
    end)
end)

zeroDelayButton = CreateButton(ButtonFrame1, "0 Delay: OFF", function()
    if not Config.ZeroDelayEnabled then
        local DelayObj = game.ReplicatedStorage:FindFirstChild("BulletHole") and game.ReplicatedStorage.BulletHole:FindFirstChild("Delay")
        if DelayObj then
            if DelayObj:FindFirstChild("Position") then
                DelayObj.Position:Destroy()
            end
            DelayObj.Position = 0
        end
        Config.ZeroDelayEnabled = true
        sendNotification("0 Delay", "Enabled")
        zeroDelayButton.Text = "0 Delay: ON"
    else
        -- nếu muốn reset thì sửa ở đây
        Config.ZeroDelayEnabled = false
        sendNotification("0 Delay", "Disabled")
        zeroDelayButton.Text = "0 Delay: OFF"
    end
    SaveSettings()
end)

-- Auto Armor Button
autoArmorEnabled = false

autoArmorButton = CreateButton(ButtonFrame1, "Auto Armor: OFF", function()
    autoArmorEnabled = not autoArmorEnabled
    autoArmorButton.Text = "Auto Armor: " .. (autoArmorEnabled and "ON" or "OFF")
    sendNotification("Auto Armor", autoArmorEnabled and "Enabled" or "Disabled")
end)

-- Auto Armor Logic
local cloneref = getgenv().cloneref or function(...) return ... end
local fireclickdetector = getgenv().fireclickdetector or function(...) return nil end
local GameReference = cloneref(Game)

if not GameReference:IsLoaded() then Game.Loaded:Wait() end

local Workspace = cloneref(GameReference:GetService("Workspace"))
local RunService = cloneref(GameReference:GetService("RunService"))
local Players = cloneref(GameReference:GetService("Players"))

local LocalPlayer = Players.LocalPlayer
local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local LocalHumanoid = LocalCharacter:FindFirstChildOfClass("Humanoid") or LocalCharacter:WaitForChild("Humanoid", 1e9)
local LocalRootPart = LocalHumanoid and LocalHumanoid.RootPart or LocalCharacter:WaitForChild("HumanoidRootPart", 1e9)

local BuyMaxDistance = 100 --// Studs \\--

LocalPlayer.CharacterAdded:Connect(function(Character)
    LocalCharacter = Character
    LocalHumanoid = LocalCharacter:FindFirstChildOfClass("Humanoid") or LocalCharacter:WaitForChild("Humanoid", 1e9)
    LocalRootPart = LocalHumanoid and LocalHumanoid.RootPart or LocalCharacter:WaitForChild("HumanoidRootPart", 1e9)
end)

RunService.PostSimulation:Connect(function()
    if not autoArmorEnabled then return end
    if not LocalCharacter or not LocalHumanoid or not LocalRootPart then return end

    local Ignored = Workspace:FindFirstChild("Ignored") or Workspace:FindFirstChild("MAP") or Workspace:FindFirstChild("Blacklisted")
    if Ignored then
        local Shop = Ignored:FindFirstChild("Shop") or Ignored:FindFirstChild("Shops") or Ignored:FindFirstChild("Pads") or Ignored:FindFirstChild("BuyPads") or Ignored:FindFirstChild("Bought")
        if Shop then
            for _, Child in ipairs(Shop:GetChildren()) do
                if Child.Name:lower():find("armor") and Child:IsA("Model") and Child:FindFirstChildOfClass("ClickDetector") then
                    local Head = Child:FindFirstChild("Head") or Child:FindFirstChild("Part")
                    if Head and Head:IsA("BasePart") and (Head.Position - LocalRootPart.Position).Magnitude <= BuyMaxDistance then
                        fireclickdetector(Child:FindFirstChildOfClass("ClickDetector"))
                    end
                end
            end
        end
    end
end)

-- Macro Legit Toggle Button
macroLegitEnabled = false

macroLegitButton = CreateButton(ButtonFrame1, "Macro Legit: OFF", function()
    macroLegitEnabled = not macroLegitEnabled
    macroLegitButton.Text = "Macro Legit: " .. (macroLegitEnabled and "ON" or "OFF")
    sendNotification("Macro Legit", macroLegitEnabled and "Enabled" or "Disabled")
end)

-- Macro Legit Logic (Hold X)
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local holdingX = false

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if macroLegitEnabled and input.KeyCode == Enum.KeyCode.X then
        holdingX = true
        task.spawn(function()
            while holdingX and macroLegitEnabled do
                RunService.Heartbeat:Wait()
                VirtualInputManager:SendMouseWheelEvent(0.1, 0.1, true, game)
                RunService.Heartbeat:Wait()
                VirtualInputManager:SendMouseWheelEvent(0.1, 0.1, false, game)
                RunService.Heartbeat:Wait()
            end
        end)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.X then
        holdingX = false
    end
end)

-- Nút Inf Ammo (thay Auto Reload cũ)
infAmmoEnabled = false

infAmmoButton = CreateButton(ButtonFrame1, "Inf Ammo: OFF", function()
    infAmmoEnabled = not infAmmoEnabled
    infAmmoButton.Text = "Inf Ammo: " .. (infAmmoEnabled and "ON" or "OFF")
    sendNotification("Inf Ammo", infAmmoEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Logic Inf Ammo
if _G.__infammo_conn then
    _G.__infammo_conn:Disconnect()
end

_G.__infammo_conn = RunService.Heartbeat:Connect(function()
    if not infAmmoEnabled then return end

    local Backpack = LocalPlayer:FindFirstChild("Backpack")
    if Backpack then
        local Ammo = Backpack:FindFirstChild("Ammo")
        if Ammo then
            Ammo.Value = 2e3
        end
    end
    
    if LocalPlayer.Character then
        local Ammo = LocalPlayer.Character:FindFirstChild("Ammo")
        if Ammo then
            Ammo.Value = 2e3
        end
    end
end)

triggerBotButton = CreateButton(ButtonFrame1, "TriggerBot: " .. (tbEnabled and "ON" or "OFF"), function()
    tbEnabled = not tbEnabled
    sendNotification("TRIGGERBOT", tbEnabled and "ON" or "OFF")
    triggerBotButton.Text = "TriggerBot: " .. (tbEnabled and "ON" or "OFF")
    SaveSettings()
end)

tpAndStompButton = CreateButton(ButtonFrame1, "TP Player", function()
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position
    if not myPos then return end

    local closestPlayer, minDist = nil, math.huge

    for name, selected in pairs(Config.SelectedPlayers) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local pos = plr.Character.HumanoidRootPart.Position
                local dist = (myPos - pos).Magnitude
                if dist < minDist then
                    closestPlayer = plr
                    minDist = dist
                end
            end
        end
    end

    if closestPlayer then
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local pos = closestPlayer.Character.HumanoidRootPart.Position
            root.CFrame = CFrame.new(pos + Vector3.new(3, 0, 0))
        end
    end
end)

-- Config mặc định
if Config.CsyncRandomEnabled == nil then Config.CsyncRandomEnabled = false end
if Config.CsyncOrbitEnabled == nil then Config.CsyncOrbitEnabled = false end
if Config.CsyncRadius == nil then Config.CsyncRadius = 10 end
if Config.CsyncHeight == nil then Config.CsyncHeight = 5 end
if Config.CsyncSpeed == nil then Config.CsyncSpeed = 2 end

-- Hàm check K.O
local function isKO(plr)
    local char = plr and plr.Character
    local be = char and char:FindFirstChild("BodyEffects")
    local ko = be and be:FindFirstChild("K.O")
    return ko and ko.Value
end

-- Hàm tìm target gần nhất
local function getClosestSelected()
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local closest, minDist
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local hrp = plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (myHRP.Position - hrp.Position).Magnitude
                if not minDist or dist < minDist then
                    closest, minDist = plr, dist
                end
            end
        end
    end
    return closest
end

-- Nút Random
csyncRandomButton = CreateButton(ButtonFrame1, "Csync Random: " .. (Config.CsyncRandomEnabled and "ON" or "OFF"), function()
    Config.CsyncRandomEnabled = not Config.CsyncRandomEnabled
    csyncRandomButton.Text = "Csync Random: " .. (Config.CsyncRandomEnabled and "ON" or "OFF")
    sendNotification("Csync Random", Config.CsyncRandomEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Nút Orbit
csyncOrbitButton = CreateButton(ButtonFrame1, "Csync Orbit: " .. (Config.CsyncOrbitEnabled and "ON" or "OFF"), function()
    Config.CsyncOrbitEnabled = not Config.CsyncOrbitEnabled
    csyncOrbitButton.Text = "Csync Orbit: " .. (Config.CsyncOrbitEnabled and "ON" or "OFF")
    sendNotification("Csync Orbit", Config.CsyncOrbitEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Frame 3 ô input
local boxFrame = Instance.new("Frame")
boxFrame.Size = UDim2.new(1, 0, 0, 40)
boxFrame.BackgroundTransparency = 1
boxFrame.Parent = ButtonFrame1

local function createLabeledBox(parent, labelText, default, onChange, pos)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1/3 - 0.02, 0, 1, 0)
    container.Position = pos
    container.BackgroundTransparency = 1
    container.Parent = parent

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 10)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextSize = 10
    label.TextColor3 = Color3.fromRGB(180, 180, 180)
    label.Font = Enum.Font.Gotham
    label.Parent = container

    local tb = Instance.new("TextBox")
    tb.Size = UDim2.new(1, 0, 0, 20)
    tb.Position = UDim2.new(0, 0, 0, 12)
    tb.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    tb.TextColor3 = Color3.new(1, 1, 1)
    tb.Text = tostring(default)
    tb.PlaceholderText = labelText
    tb.ClearTextOnFocus = false
    tb.Font = Enum.Font.GothamBold
    tb.TextSize = 12
    tb.Parent = container
    Instance.new("UICorner", tb).CornerRadius = UDim.new(0, 4)

    tb.FocusLost:Connect(function()
        local num = tonumber(tb.Text)
        if num then
            onChange(num)
            SaveSettings()
        else
            tb.Text = tostring(default)
        end
    end)
end

createLabeledBox(boxFrame, "Radius", Config.CsyncRadius, function(v) Config.CsyncRadius = v end, UDim2.new(0, 0, 0, 0))
createLabeledBox(boxFrame, "Height", Config.CsyncHeight, function(v) Config.CsyncHeight = v end, UDim2.new(1/3, 0, 0, 0))
createLabeledBox(boxFrame, "Speed",  Config.CsyncSpeed,  function(v) Config.CsyncSpeed  = v end, UDim2.new(2/3, 0, 0, 0))

-- ========================
-- Logic chạy Orbit/Random
-- ========================
local pausedRandom, pausedOrbit = false, false

if _G.VHUB_CSYNC_LOOP then _G.VHUB_CSYNC_LOOP:Disconnect() end
_G.VHUB_CSYNC_LOOP = RunService.Heartbeat:Connect(function()
    local target = getClosestSelected()
    if target then
        if isKO(target) then
            if Config.CsyncRandomEnabled then
                pausedRandom = true
                Config.CsyncRandomEnabled = false
                csyncRandomButton.Text = "Csync Random: OFF"
                sendNotification("Csync Random", "Paused (target KO)")
            end
            if Config.CsyncOrbitEnabled then
                pausedOrbit = true
                Config.CsyncOrbitEnabled = false
                csyncOrbitButton.Text = "Csync Orbit: OFF"
                sendNotification("Csync Orbit", "Paused (target KO)")
            end
        else
            if pausedRandom then
                Config.CsyncRandomEnabled = true
                pausedRandom = false
                csyncRandomButton.Text = "Csync Random: ON"
                sendNotification("Csync Random", "Resumed")
            end
            if pausedOrbit then
                Config.CsyncOrbitEnabled = true
                pausedOrbit = false
                csyncOrbitButton.Text = "Csync Orbit: ON"
                sendNotification("Csync Orbit", "Resumed")
            end
        end

        if Config.CsyncOrbitEnabled then
            local hrp = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp and myHRP then
                local t = tick() * Config.CsyncSpeed
                local pos = hrp.Position + Vector3.new(math.cos(t) * Config.CsyncRadius, Config.CsyncHeight, math.sin(t) * Config.CsyncRadius)
                myHRP.CFrame = CFrame.new(pos, hrp.Position)
            end
        end

        if Config.CsyncRandomEnabled then
            local hrp = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp and myHRP then
                local offset = Vector3.new(math.random(-Config.CsyncRadius, Config.CsyncRadius), Config.CsyncHeight, math.random(-Config.CsyncRadius, Config.CsyncRadius))
                myHRP.CFrame = CFrame.new(hrp.Position + offset, hrp.Position)
            end
        end
    end
end)

-- Logic Csync
RunService.RenderStepped:Connect(function()
    local target = getClosestSelected()
    if not target then return end
    local thrp = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not thrp or not myHRP then return end

    if Config.CsyncRandomEnabled then
        local angle = math.random() * math.pi * 2
        local offset = Vector3.new(math.cos(angle) * Config.CsyncRadius, Config.CsyncHeight, math.sin(angle) * Config.CsyncRadius)
        myHRP.CFrame = CFrame.new(thrp.Position + offset, thrp.Position)
    elseif Config.CsyncOrbitEnabled then
        local time = tick() * Config.CsyncSpeed
        local offset = Vector3.new(math.cos(time) * Config.CsyncRadius, Config.CsyncHeight, math.sin(time) * Config.CsyncRadius)
        myHRP.CFrame = CFrame.new(thrp.Position + offset, thrp.Position)
    end
end)

-- Nút cho trang 2 (chia trái phải)
local customFovEnabled = false
local defaultFov = Workspace.CurrentCamera.FieldOfView

customFovButton = CreateButton(ButtonFrame2Left, "Custom FOV: OFF", function()
    customFovEnabled = not customFovEnabled
    customFovButton.Text = "Custom FOV: " .. (customFovEnabled and "ON" or "OFF")

    if customFovEnabled then
        local num = tonumber(fovBox.Text)
        if num and num >= 40 and num <= 120 then
            Workspace.CurrentCamera.FieldOfView = num
            sendNotification("Custom FOV", "Đã đặt FOV thành " .. num)
        else
            sendNotification("Custom FOV", "Hãy nhập giá trị 40-120 vào ô FOV")
        end
    else
        Workspace.CurrentCamera.FieldOfView = defaultFov
    end
    SaveSettings()
end)

-- Ô nhập giá trị FOV
local fovBox = Instance.new("TextBox")
fovBox.Size = UDim2.new(1, -10, 0, 25)
fovBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
fovBox.BackgroundTransparency = 0.2
fovBox.TextColor3 = Color3.fromRGB(0, 0, 0)
fovBox.TextSize = 14
fovBox.Font = Enum.Font.Gotham
fovBox.PlaceholderText = "Nhập FOV (mặc định: "..defaultFov..")"
fovBox.ClearTextOnFocus = false
fovBox.Parent = ButtonFrame2Left
Instance.new("UICorner", fovBox).CornerRadius = UDim.new(0, 6)

fovBox:GetPropertyChangedSignal("Text"):Connect(function()
    if customFovEnabled then
        local num = tonumber(fovBox.Text)
        if num and num >= 40 and num <= 120 then
            Workspace.CurrentCamera.FieldOfView = num
            sendNotification("Custom FOV", "Đã đặt FOV thành " .. num)
            SaveSettings()
        end
    end
end)

fullbrightButton = CreateButton(ButtonFrame2Left, "Fullbright: OFF", function()
    Config.FullbrightEnabled = not Config.FullbrightEnabled
    if Config.FullbrightEnabled then
        Lighting.Brightness = 2
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 999999
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
        Lighting.ClockTime = 12
    else
        Lighting.Brightness = oldLighting.Brightness
        Lighting.GlobalShadows = oldLighting.GlobalShadows
        Lighting.FogEnd = oldLighting.FogEnd
        Lighting.Ambient = oldLighting.Ambient
        Lighting.OutdoorAmbient = oldLighting.OutdoorAmbient
        Lighting.ClockTime = oldLighting.ClockTime
    end
    sendNotification("FULLBRIGHT", Config.FullbrightEnabled and "ON" or "OFF")
    fullbrightButton.Text = "Fullbright: " .. (Config.FullbrightEnabled and "ON" or "OFF")
    SaveSettings()
end)

-- Auto Wallhop Button
autoWallhopEnabled = false
autoWallhopButton = CreateButton(ButtonFrame2Left, "Auto Wallhop: OFF", function()
    autoWallhopEnabled = not autoWallhopEnabled
    autoWallhopButton.Text = "Auto Wallhop: " .. (autoWallhopEnabled and "ON" or "OFF")
    sendNotification("Auto Wallhop", autoWallhopEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Wallhop Logic
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local isPerformingWallHop = false

-- Detect wall in front
local function isWallInFront()
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local raycastResult = Workspace:Raycast(rootPart.Position, rootPart.CFrame.LookVector * 2, raycastParams)
    return raycastResult and raycastResult.Instance ~= nil
end

-- Perform wallhop
local function performWallHop()
    if not autoWallhopEnabled or isPerformingWallHop then return end
    isPerformingWallHop = true
    while autoWallhopEnabled and isWallInFront() do
        humanoid.Jump = true
        rootPart.Velocity = Vector3.new(0, 60, 0) -- lực nhảy
        task.wait(0) -- chờ nhảy
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(-35), 0) -- xoay nhẹ
        task.wait(0.4) -- delay
    end
    isPerformingWallHop = false
end

-- Loop check
RunService.Heartbeat:Connect(function()
    if autoWallhopEnabled then
        performWallHop()
    end
end)

infiniteJumpButton = CreateButton(ButtonFrame2Left, "Infinite Jump: OFF", function()
    Config.infiniteJumpEnabled = not Config.infiniteJumpEnabled
    sendNotification("INFINITIEJUMP", Config.infiniteJumpEnabled and "ON" or "OFF")
    infiniteJumpButton.Text = "Infinite Jump: " .. (Config.infiniteJumpEnabled and "ON" or "OFF")
    SaveSettings()
end)

-- JumpRequest chạy khi bấm Space (PC) hoặc nút nhảy mặc định (Mobile)
UserInputService.JumpRequest:Connect(function()
    if Config.infiniteJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

local antiAfkEnabled = false
local antiAfkLoop

antiAfkButton = CreateButton(ButtonFrame2Left, "Anti AFK: OFF", function()
    antiAfkEnabled = not antiAfkEnabled
    antiAfkButton.Text = "Anti AFK: " .. (antiAfkEnabled and "ON" or "OFF")
    sendNotification("ANTI AFK", antiAfkEnabled and "ON" or "OFF")

    if antiAfkEnabled then
        -- Vòng lặp tự nhảy mỗi 60 giây
        antiAfkLoop = task.spawn(function()
            while antiAfkEnabled do
                task.wait(60) -- Đợi 60 giây
                pcall(function()
                    local hum = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end)
            end
        end)
    else
        if antiAfkLoop then
            task.cancel(antiAfkLoop)
            antiAfkLoop = nil
        end
    end
end)

noclipButton = CreateButton(ButtonFrame2Left, "Noclip: OFF", function()
    Config.NoclipEnabled = not Config.NoclipEnabled
    
    if Config.NoclipEnabled then
        if noclipConnection then noclipConnection:Disconnect() end
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
    end

    sendNotification("NOCLIP", Config.NoclipEnabled and "ON" or "OFF")
    noclipButton.Text = "Noclip: " .. (Config.NoclipEnabled and "ON" or "OFF")
    SaveSettings()
end)

-- Đảm bảo noclip vẫn bật khi respawn
LocalPlayer.CharacterAdded:Connect(function()
    if Config.NoclipEnabled then
        task.wait(0.5) -- đợi nhân vật load
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- ID animation
local animations = {
    happier = "http://www.roblox.com/asset/?id=15609995579",
    happy   = "http://www.roblox.com/asset/?id=14352343065",
}

local currentTrack = nil

-- Hàm phát animation
local function playAnimation(animId)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChildOfClass("Humanoid") then return end
    local hum = char:FindFirstChildOfClass("Humanoid")

    -- Đang di chuyển thì không phát
    if hum.MoveDirection.Magnitude > 0 then return end

    -- Ngừng animation cũ
    if currentTrack then
        currentTrack:Stop()
        currentTrack = nil
    end

    -- Tạo animator nếu chưa có
    local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    local track = animator:LoadAnimation(anim)
    track:Play()
    currentTrack = track
end

-- Khi respawn vẫn dùng được
LocalPlayer.CharacterAdded:Connect(function()
    currentTrack = nil
end)

-- Tạo 2 nút
CreateButton(ButtonFrame2Right, "Happier Jump", function()
    playAnimation(animations.happier)
end)

CreateButton(ButtonFrame2Right, "Happy", function()
    playAnimation(animations.happy)
end)


local function giveClickTpTool()
    if clickTpTool then clickTpTool:Destroy() end
    clickTpTool = Instance.new("Tool")
    clickTpTool.RequiresHandle = false
    clickTpTool.Name = "ClickTP"
    clickTpTool.Parent = LocalPlayer.Backpack

    clickTpTool.Activated:Connect(function()
        local mouse = LocalPlayer:GetMouse()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if mouse and mouse.Hit then
                local targetPos = mouse.Hit.p + Vector3.new(0, 3, 0) -- cách mặt đất 3 stud
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
            end
        end
    end)
end

-- Nút bật/tắt
clickTpButton = CreateButton(ButtonFrame2Right, "Click TP: OFF", function()
    Config.clickTpEnabled = not Config.clickTpEnabled
    sendNotification("GIVECLICKTOOL", Config.clickTpEnabled and "ON" or "OFF")
    clickTpButton.Text = "Click TP: " .. (Config.clickTpEnabled and "ON" or "OFF")
    SaveSettings()

    if Config.clickTpEnabled then
        giveClickTpTool()
        sendNotification("Click TP", "Đã cấp tool Click TP vào Backpack!")
    else
        if clickTpTool then
            clickTpTool:Destroy()
            clickTpTool = nil
        end
    end
end)

-- Khi respawn thì gắn lại tool nếu đang bật
LocalPlayer.CharacterAdded:Connect(function()
    if Config.clickTpEnabled then
        task.wait(0.5) -- đợi nhân vật load
        giveClickTpTool()
    end
end)

saveWaypointButton = CreateButton(ButtonFrame2Right, "Save Waypoint", function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        savedWaypoint = LocalPlayer.Character.HumanoidRootPart.CFrame
        sendNotification("Waypoint", "Đã lưu vị trí hiện tại!")
    else
        sendNotification("Waypoint", "Không thể lưu vị trí!")
    end
end)

tpWaypointButton = CreateButton(ButtonFrame2Right, "TP to Waypoint", function()
    if savedWaypoint and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = savedWaypoint
        sendNotification("Waypoint", "Đã teleport tới vị trí đã lưu!")
    else
        sendNotification("Waypoint", "Chưa có vị trí được lưu!")
    end
end)

local hiddenFling = false
local flingPower = 55000
local movel = 0.1

local function flingLoop()
    local lp = Players.LocalPlayer
    local hrp, c, vel

    task.spawn(function()
        while true do
            RunService.Heartbeat:Wait()
            if hiddenFling then
                while hiddenFling and not (c and c.Parent and hrp and hrp.Parent) do
                    RunService.Heartbeat:Wait()
                    c = lp.Character
                    hrp = c and c:FindFirstChild("HumanoidRootPart")
                end

                if hiddenFling and hrp then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                    RunService.RenderStepped:Wait()
                    if hrp.Parent then
                        hrp.Velocity = vel
                    end
                    RunService.Stepped:Wait()
                    if hrp.Parent then
                        hrp.Velocity = vel + Vector3.new(0, movel, 0)
                        movel = movel * -1
                    end
                end
            end
        end
    end)
end

flingLoop()

flintTouchButton = CreateButton(ButtonFrame2Right, "FlintTouch: OFF", function()
    hiddenFling = not hiddenFling
    sendNotification("FLINGTOUCH", hiddenFling and "ON" or "OFF")
    flintTouchButton.Text = "FlintTouch: " .. (hiddenFling and "ON" or "OFF")
    SaveSettings()
end)

local function FlingAll()
    hiddenFling = true
    flintTouchButton.Text = "FlintTouch: ON"
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local targetRoot = plr.Character.HumanoidRootPart
            for i = 1, 10 do  -- Di chuyển đi lại 5 lần để fling hiệu quả
                myRoot.CFrame = targetRoot.CFrame + Vector3.new(math.random(-2, 2), 0, math.random(-2, 2))
                task.wait(0.05)
                myRoot.CFrame = targetRoot.CFrame + Vector3.new(math.random(-2, 2), 0, math.random(-2, 2))
                task.wait(0.05)
            end
        end
    end
end

flingAllButton = CreateButton(ButtonFrame2Right, "Fling All", FlingAll)

-- Anti Fling Button (Page 2, Right Side)
antiFlingEnabled = false

antiFlingButton = CreateButton(ButtonFrame2Right, "Anti Fling: OFF", function()
    antiFlingEnabled = not antiFlingEnabled
    antiFlingButton.Text = "Anti Fling: " .. (antiFlingEnabled and "ON" or "OFF")
    sendNotification("Anti Fling", antiFlingEnabled and "Enabled" or "Disabled")
    SaveSettings()
end)

-- Anti Fling Logic
if _G.__antifling_conn then
    _G.__antifling_conn:Disconnect()
end

_G.__antifling_conn = RunService.Heartbeat:Connect(function()
    if not antiFlingEnabled then return end
    pcall(function()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = plr.Character.HumanoidRootPart
                hrp.Velocity = Vector3.new(0, 0, 0)
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end)

-- ESP
local espGui = Instance.new("ScreenGui")
espGui.Name = "SafeESP"
espGui.ResetOnSpawn = false
espGui.IgnoreGuiInset = true
espGui.Parent = PlayerGui

local ESPs = {}

local function IsValidTarget(player)
    if not player 
        or not player.Character 
        or not player.Character:FindFirstChild("Humanoid") 
        or not player.Character:FindFirstChild("HumanoidRootPart") 
        or player.Character.Humanoid.Health <= 0 then
        return false
    end
    
    -- Kiểm tra trạng thái K.O nếu checkKOAimbot được bật
    if Config.checkKOAimbot then
        local bodyEffects = player.Character:FindFirstChild("BodyEffects")
        local koValue = bodyEffects and bodyEffects:FindFirstChild("K.O")
        if koValue and koValue.Value then
            return false -- Bỏ qua người chơi nếu họ bị K.O
        end
    end
    
    return true
end

local function CreateESP(player)
    if ESPs[player] or player == LocalPlayer then return end
    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 179, 186)
    label.TextSize = 16
    label.Font = Enum.Font.GothamBold
    label.Text = player.DisplayName
    label.TextStrokeTransparency = 0.5
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.Size = UDim2.new(0, 200, 0, 20)
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.Visible = false
    label.Parent = espGui

    local highlight = Instance.new("Highlight")
    highlight.Enabled = false
    highlight.FillTransparency = 0.6
    highlight.OutlineTransparency = 0.2
    highlight.FillColor = Color3.fromRGB(255, 179, 186)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.Adornee = player.Character
    highlight.Parent = espGui

    ESPs[player] = { label = label, highlight = highlight }
end

local function RemoveESP(player)
    if ESPs[player] then
        pcall(function()
            ESPs[player].label:Destroy()
            ESPs[player].highlight:Destroy()
        end)
        ESPs[player] = nil
    end
end

local function UpdateESP()
    if not Config.ESPEnabled then
        for _, v in pairs(ESPs) do
            v.label.Visible = false
            v.highlight.Enabled = false
        end
        return
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and IsValidTarget(player) then
            local character = player.Character
            local head = character:FindFirstChild("Head")
            if head then
                CreateESP(player)
                local headPos = head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
                local esp = ESPs[player]
                if esp then
                    local isSelected = Config.SelectedPlayers[player.Name]
                    esp.label.TextColor3 = isSelected and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 255, 255)
                    esp.highlight.FillColor = isSelected and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 255, 255)
                    if onScreen then
                        esp.label.Visible = true
                        esp.label.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y - 20)
                        esp.highlight.Enabled = true
                    else
                        esp.label.Visible = false
                        esp.highlight.Enabled = false
                    end
                end
            else
                RemoveESP(player)
            end
        else
            RemoveESP(player)
        end
    end
end

local function UpdateSpeed()
    if Config.SpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local humanoid = LocalPlayer.Character.Humanoid
        local moveDirection = humanoid.MoveDirection
        local speedAmount = Config.SpeedAmount / 8
        root.CFrame = root.CFrame + moveDirection * speedAmount
    end
end

local function UpdateFly(deltaTime)
    if Config.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local moveDirection = LocalPlayer.Character.Humanoid.MoveDirection
        local flySpeed = Config.FlySpeed
        local vertical = UserInputService:IsKeyDown(Enum.KeyCode.Space) and flySpeed / 8 or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and -flySpeed / 8 or 0
        root.CFrame = root.CFrame + moveDirection * deltaTime * flySpeed * 10
        root.CFrame = root.CFrame + Vector3.new(0, vertical, 0)
        root.Velocity = root.Velocity * Vector3.new(1, 0, 1) + Vector3.new(0, 1.9, 0)
    end
end

local function UpdatePlayerList()
    for _, cd in pairs(PlayerList:GetChildren()) do
        if cd:IsA("TextButton") then cd:Destroy() end
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, -4, 0, 20)
            button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            button.BackgroundTransparency = 0.2
            button.TextColor3 = Color3.fromRGB(0, 0, 0)
            button.TextSize = 14
            button.Font = Enum.Font.Gotham
            button.AutoButtonColor = false
            button.Parent = PlayerList
            local function UpdateButtonText()
                local isSelected = Config.SelectedPlayers[player.Name]
                button.Text = (isSelected and "✓ " or "") .. player.DisplayName
            end
            button.MouseButton1Click:Connect(function()
                Config.SelectedPlayers[player.Name] = not Config.SelectedPlayers[player.Name]
                UpdateButtonText()
                SaveSettings()
            end)
            animateButton(button)
            UpdateButtonText()
        end
    end
end

local hitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}

local function validPart(p)
    if not p or not p.Parent or not p.Parent:FindFirstChild("Humanoid") then return false end
    local player = Players:GetPlayerFromCharacter(p.Parent)
    if not player or not Config.SelectedPlayers[player.Name] then return false end
    for _, n in ipairs(hitParts) do
        if p.Name:lower() == n:lower() then return true end
    end
    return false
end

local function distToCursor(part)
    local v, vis = Camera:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UserInputService.TouchEnabled and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) or UserInputService:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - Vector2.new(m.X, m.Y)).Magnitude
end

local function click()
    if UserInputService.TouchEnabled then
        local touchPos = UserInputService:GetMouseLocation()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        if mouse1press then
            mouse1press()
            mouse1release()
        elseif mouse1click then
            mouse1click()
        end
    end
end

local function GetBestTargetPart()
    local bestPart, bestDist = nil, fovRadius
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and Config.SelectedPlayers[plr.Name] and IsValidTarget(plr) and plr.Character then
            for _, partName in ipairs(hitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

getgenv().Aimbot = {
    Status = true,
    Hitpart = "Head",
}

local function GetPing()
    if Config.CustomPing then
        return Config.CustomPing
    end
    local stats = game:GetService("Stats"):FindFirstChild("Network")
    local data = stats and stats:FindFirstChild("DataPing")
    return data and math.clamp(data:GetValue(), 10, 300) or 40
end

local function GetPredictedPosition(part)
    if not part or not part:IsA("BasePart") then return part.Position end
    local velocity = part.Velocity
    local origin = Camera.CFrame.Position
    local distance = (part.Position - origin).Magnitude
    local ping = GetPing()
    local delay = ping / 1000
    local distanceFactor = math.clamp(distance / 100, 1, 3)
    return part.Position + velocity * delay * distanceFactor
end

local function IsObstructed(origin, targetPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = Workspace:Raycast(origin, (targetPos - origin), raycastParams)
    if result and result.Instance and not result.Instance:IsDescendantOf(Player and Player.Character) then
        return true
    end
    return false
end

local function GetClosestValidPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and Config.SelectedPlayers[plr.Name] and IsValidTarget(plr) and plr.Character and plr.Character:FindFirstChild(getgenv().Aimbot.Hitpart) then
            local pos, visible = Camera:WorldToViewportPoint(plr.Character[getgenv().Aimbot.Hitpart].Position)
            if visible then
                local dist = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(pos.X, pos.Y)).Magnitude
                if dist < shortestDistance then
                    closestPlayer = plr
                    shortestDistance = dist
                end
            end
        end
    end
    return closestPlayer
end

RunService.RenderStepped:Connect(function(deltaTime)
    UpdateESP()
    UpdateSpeed()
    UpdateFly(deltaTime)

    if Config.AimbotEnabled and getgenv().Aimbot.Status then
        Player = GetClosestValidPlayer()
        if Player and Player.Character and Player.Character:FindFirstChild(getgenv().Aimbot.Hitpart) then
            local part = Player.Character[getgenv().Aimbot.Hitpart]
            local predictedPos = GetPredictedPosition(part)
            if not IsObstructed(Camera.CFrame.Position, predictedPos) then
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, predictedPos)
            end
        end
    end

    if tbEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(0)
                if tbEnabled and distToCursor(cap) <= fovRadius then
                    -- Kiểm tra raycast
                    local origin = Camera.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}

                    local result = Workspace:Raycast(origin, direction, rayParams)

                    -- Nếu không có va chạm hoặc hit trúng đúng part của target => bắn
                    if not result or result.Instance:IsDescendantOf(cap.Parent) then
                        click()
                    end
                end
            end)
        end
    end
end)

local Connections = {}
local function Connect(event, callback)
    local connection = event:Connect(callback)
    table.insert(Connections, connection)
    return connection
end

Connect(Players.PlayerRemoving, function(player)
    RemoveESP(player)
    UpdatePlayerList()
end)

Connect(Players.PlayerAdded, function(player)
    task.wait(math.random(2, 3))
    RemoveESP(player)
    if Config.SelectedPlayers[player.Name] then
        Config.SelectedPlayers[player.Name] = true 
    end
    UpdatePlayerList()
end)

task.spawn(function()
    while true do
        UpdatePlayerList()
        task.wait(math.random(12, 15))
    end
end)

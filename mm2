-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local localPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Configuration
local CONFIG = {
    ESP_ENABLED = false,
    SHOOT_OFFSET = 2.8,
    OFFSET_TO_PING_MULT = 1,
    UPDATE_INTERVAL = 0.5,
    RANDOM_DELAY = 0.1,
    MAX_COIN_DISTANCE = 100,
    MAX_GUN_DISTANCE = 500,
    ANTI_CHEAT_DELAY = 0.07
}

-- Variables
local playerData = {}
local espObjects = {}
local isScriptRunning = false
local espActive = CONFIG.ESP_ENABLED
local autoFarm = false
local lastUpdate = tick()
local lastShot = tick()
local autoFarmTask = nil

-- Game checks
local function isMurderMystery2()
    return ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Gameplay")
end

local function getMap()
    for _, obj in ipairs(Workspace:GetChildren()) do
        if obj:GetAttribute("MapID") and obj:FindFirstChild("CoinContainer") and obj:FindFirstChild("Spawns") then
            return obj
        end
    end
    return nil
end

-- Role detection
local function findMurderer()
    if playerData then
        for playerName, data in pairs(playerData) do
            if data.Role == "Murderer" then
                local player = Players:FindFirstChild(playerName)
                if player and player.Character then
                    return player
                end
            end
        end
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            if player.Backpack:FindFirstChild("Knife") or (player.Character and player.Character:FindFirstChild("Knife")) then
                return player
            end
        end
    end
    return nil
end

local function findSheriff()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and (player.Backpack:FindFirstChild("Gun") or (player.Character and player.Character:FindFirstChild("Gun"))) then
            return player
        end
    end
    if playerData then
        for playerName, data in pairs(playerData) do
            if data.Role == "Sheriff" then
                local player = Players:FindFirstChild(playerName)
                if player and player.Character then
                    return player
                end
            end
        end
    end
    return nil
end

local function findSheriffNotMe()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and (player.Backpack:FindFirstChild("Gun") or (player.Character and player.Character:FindFirstChild("Gun"))) then
            return player
        end
    end
    if playerData then
        for playerName, data in pairs(playerData) do
            if data.Role == "Sheriff" and Players:FindFirstChild(playerName) ~= localPlayer then
                local player = Players:FindFirstChild(playerName)
                if player and player.Character then
                    return player
                end
            end
        end
    end
    return nil
end

-- ESP functions
local function createESP(object, color)
    if not espActive or not object then return end
    pcall(function()
        if espObjects[object] then
            espObjects[object].highlight:Destroy()
            espObjects[object] = nil
        end
        local highlight = Instance.new("Highlight")
        highlight.Parent = object
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.6
        highlight.OutlineTransparency = 0.2
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        espObjects[object] = { highlight = highlight }
    end)
end

local function clearESP()
    for object, esp in pairs(espObjects) do
        pcall(function()
            esp.highlight:Destroy()
        end)
    end
    espObjects = {}
end

local function reloadPlayerESP()
    if not espActive or tick() - lastUpdate < CONFIG.UPDATE_INTERVAL then return end
    lastUpdate = tick()
    clearESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player ~= localPlayer then
            local color
            if player == findMurderer() then
                color = Color3.fromRGB(255, 0, 0) -- Red for Murderer
            elseif player == findSheriff() then
                color = Color3.fromRGB(0, 153, 255) -- Blue for Sheriff
            else
                color = Color3.fromRGB(0, 255, 0) -- Green for others
            end
            createESP(player.Character, color)
        end
    end
    task.wait(math.random(0, CONFIG.RANDOM_DELAY))
end

-- Predicted position
local function getPredictedPosition(player, shootOffset)
    local success, result = pcall(function()
        if not player.Character then return Vector3.zero end
        local hrp = player.Character:FindFirstChild("UpperTorso")
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not hrp or not humanoid then return Vector3.zero end
        local position = hrp.Position
        local velocity = hrp.AssemblyLinearVelocity
        local moveDirection = humanoid.MoveDirection
        local predicted = position + (velocity * Vector3.new(0, 0.5, 0)) * (shootOffset / 15) + moveDirection * shootOffset
        predicted = predicted * (((localPlayer:GetNetworkPing() * 1000) * ((CONFIG.OFFSET_TO_PING_MULT - 1) * 0.01)) + 1)
        return predicted
    end)
    return success and result or Vector3.zero
end

-- Shoot Murderer
local function shootMurderer()
    if tick() - lastShot < 0.5 + math.random(0, CONFIG.ANTI_CHEAT_DELAY) then return end
    lastShot = tick()
    if findSheriff() ~= localPlayer then return end
    local target = findMurderer() or findSheriffNotMe()
    if not target or not target.Character then return end
    local gun = localPlayer.Character:FindFirstChild("Gun") or localPlayer.Backpack:FindFirstChild("Gun")
    if not gun then return end
    if gun.Parent == localPlayer.Backpack then
        local humanoid = localPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:EquipTool(gun)
            task.wait(math.random(0.05, 0.1) + CONFIG.ANTI_CHEAT_DELAY)
        end
    end
    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end
    local predictedPos = getPredictedPosition(target, CONFIG.SHOOT_OFFSET)
    if predictedPos == Vector3.zero then return end
    if (localPlayer.Character.HumanoidRootPart.Position - predictedPos).Magnitude > CONFIG.MAX_GUN_DISTANCE then return end
    pcall(function()
        local args = { [1] = 1, [2] = predictedPos, [3] = "AH2" }
        local gunLocal = localPlayer.Character:FindFirstChild("Gun") and localPlayer.Character.Gun:FindFirstChild("KnifeLocal")
        if gunLocal and gunLocal:FindFirstChild("CreateBeam") then
            gunLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
        end
    end)
    task.wait(math.random(0, CONFIG.ANTI_CHEAT_DELAY))
end

-- AutoFarm Coins
local function autoFarmCoins()
    local humanoidRootPart = localPlayer.Character and localPlayer.Character:WaitForChild("HumanoidRootPart", 5)
    local humanoid = localPlayer.Character and localPlayer.Character:WaitForChild("Humanoid", 5)
    if not humanoidRootPart or not humanoid then return end

    local function findCoin()
        local map = getMap()
        if not map or not map:FindFirstChild("CoinContainer") then return nil end
        local closestCoin, minDist = nil, math.huge
        for _, coin in ipairs(map.CoinContainer:GetChildren()) do
            local coinVisual = coin:FindFirstChild("CoinVisual")
            if coinVisual and not coinVisual:GetAttribute("Collected") and coin.Parent then
                local dist = (humanoidRootPart.Position - coin.Position).Magnitude
                if dist < minDist and dist < CONFIG.MAX_COIN_DISTANCE then
                    closestCoin = coin
                    minDist = dist
                end
            end
        end
        return closestCoin
    end

    local function moveToCoin(coin)
        if not coin or not coin.Parent then return end
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        local distance = (humanoidRootPart.Position - coin.Position).Magnitude
        if distance > CONFIG.MAX_COIN_DISTANCE then return end
        local offset = Vector3.new(math.random(-5, 5)/10, 0, math.random(-5, 5)/10)
        local tween = TweenService:Create(
            humanoidRootPart,
            TweenInfo.new(distance / 25, Enum.EasingStyle.Linear),
            {CFrame = coin.CFrame * CFrame.Angles(0, math.rad(math.random(-10, 10)), 0) + offset}
        )
        tween:Play()
        tween.Completed:Wait()
    end

    while autoFarm do
        local coin = findCoin()
        if coin then
            moveToCoin(coin)
            local coinVisual = coin:FindFirstChild("CoinVisual")
            while coinVisual and not coinVisual:GetAttribute("Collected") and coinVisual.Parent and autoFarm do
                local newCoin = findCoin()
                if newCoin and newCoin ~= coin then break end
                task.wait(0.1 + math.random(0, CONFIG.ANTI_CHEAT_DELAY))
            end
        end
        task.wait(math.random(0.1, 0.3))
    end
end

-- Line of Sight Check
local function checkLineOfSight(startPos, endPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {localPlayer.Character, Workspace:FindFirstChild("CoinContainer")}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    local raycastResult = Workspace:Raycast(startPos, (endPos - startPos).Unit * (endPos - startPos).Magnitude, raycastParams)
    return not raycastResult or raycastResult.Instance:IsDescendantOf(findMurderer() and findMurderer().Character)
end

-- Auto-Shoot when Sheriff
RunService.Heartbeat:Connect(function()
    if not autoFarm or not isScriptRunning then return end
    if findSheriff() == localPlayer then
        local murderer = findMurderer()
        if murderer and murderer.Character and murderer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local startPos = localPlayer.Character.HumanoidRootPart.Position
            local endPos = murderer.Character.HumanoidRootPart.Position
            if checkLineOfSight(startPos, endPos) then
                task.spawn(shootMurderer)
            end
        end
    end
end)

-- Event connections
Workspace.ChildAdded:Connect(function(child)
    if child == getMap() and espActive then
        task.wait(math.random(1, 2))
        reloadPlayerESP()
    end
end)

Workspace.ChildRemoved:Connect(function(child)
    if child == getMap() and espActive then
        clearESP()
    end
end)

localPlayer.CharacterAdded:Connect(function()
    task.wait(3) -- Increased delay to ensure roles are fully loaded
    if autoFarm then
        if autoFarmTask then task.cancel(autoFarmTask) end
        autoFarmTask = task.spawn(autoFarmCoins)
    end
    if espActive then
        reloadPlayerESP()
    end
end)

Players.PlayerAdded:Connect(function(player)
    if player ~= localPlayer then
        player.CharacterAdded:Connect(function()
            if espActive then
                task.wait(math.random(0.5, 1.5))
                reloadPlayerESP()
            end
        end)
    end
end)

Players.PlayerRemoving:Connect(function()
    if espActive then
        task.wait(math.random(0.5, 1.5))
        reloadPlayerESP()
    end
end)

-- GUI setup
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = localPlayer:WaitForChild("PlayerGui", 5)
screenGui.Name = "MurderMystery2GUI"
screenGui.ResetOnSpawn = false

local mainFrame = Instance.new("Frame")
mainFrame.Parent = screenGui
mainFrame.Position = UDim2.new(0.161, 0, 0.21, 0)
mainFrame.Size = UDim2.new(0, 120, 0, 120)
mainFrame.BackgroundColor3 = Color3.fromRGB(255, 179, 186)
mainFrame.Active = true
mainFrame.Draggable = true

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainFrame

local function createButton(name, position, text, active)
    local button = Instance.new("TextButton")
    button.Parent = mainFrame
    button.Name = name
    button.Position = position
    button.Size = UDim2.new(0, 100, 0, 25)
    button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    button.Text = text
    button.Font = Enum.Font.SourceSansBold
    button.TextColor3 = Color3.fromRGB(0, 0, 0)
    button.TextSize = 12
    button.Active = active
    button.Selectable = active
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 8)
    btnCorner.Parent = button
    return button
end

local autoFarmButton = createButton("AutoFarmBtn", UDim2.new(0.083, 0, 0.05, 0), "AutoFarm (Off)", true)
local shootButton = createButton("ShootBtn", UDim2.new(0.083, 0, 0.283, 0), "Shoot", true)
local espButton = createButton("ESPBtn", UDim2.new(0.083, 0, 0.517, 0), "ESP (Off)", true)
local autoGunButton = createButton("AutoGunBtn", UDim2.new(0.083, 0, 0.75, 0), "AutoGun (Not Working)", false)

-- Button functionality
autoFarmButton.MouseButton1Click:Connect(function()
    autoFarm = not autoFarm
    autoFarmButton.Text = "AutoFarm (" .. (autoFarm and "On" or "Off") .. ")"
    if autoFarm then
        if autoFarmTask then task.cancel(autoFarmTask) end
        autoFarmTask = task.spawn(autoFarmCoins)
    else
        if autoFarmTask then
            task.cancel(autoFarmTask)
            autoFarmTask = nil
        end
    end
end)

shootButton.MouseButton1Click:Connect(function()
    task.spawn(shootMurderer)
end)

espButton.MouseButton1Click:Connect(function()
    espActive = not espActive
    espButton.Text = "ESP (" .. (espActive and "On" or "Off") .. ")"
    if espActive then
        reloadPlayerESP()
    else
        clearESP()
    end
end)

-- Input bindings
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent or not isScriptRunning then return end
    if input.KeyCode == Enum.KeyCode.T then
        espActive = not espActive
        espButton.Text = "ESP (" .. (espActive and "On" or "Off") .. ")"
        if espActive then
            reloadPlayerESP()
        else
            clearESP()
        end
    elseif input.UserInputType == Enum.UserInputType.MouseButton3 then -- Changed to MouseButton2 (right-click)
        task.spawn(shootMurderer)
    end
end)

-- Periodic ESP update
RunService.Stepped:Connect(function()
    if espActive and isScriptRunning then
        reloadPlayerESP()
    end
end)

-- Initialize
local function initialize()
    local success = pcall(function()
        localPlayer:WaitForChild("PlayerGui", 10)
        ReplicatedStorage:WaitForChild("Remotes", 10):WaitForChild("Gameplay", 10):WaitForChild("PlayerDataChanged", 10)
    end)
    if not success or not isMurderMystery2() then
        warn("Failed to initialize: Game is not Murder Mystery 2 or required objects not found.")
        return
    end
    isScriptRunning = true
    pcall(function()
        local gameplay = ReplicatedStorage.Remotes.Gameplay.PlayerDataChanged
        gameplay.OnClientEvent:Connect(function(data)
            playerData = data
            if espActive then
                task.wait(0.5) -- Ensure data is updated before reloading ESP
                reloadPlayerESP()
            end
        end)
    end)
    task.wait(3) -- Increased delay to ensure roles are loaded
    if espActive then
        reloadPlayerESP()
    end
end

-- Cleanup
local function cleanup()
    if autoFarmTask then
        task.cancel(autoFarmTask)
        autoFarmTask = nil
    end
    clearESP()
    autoFarm = false
    espActive = false
    isScriptRunning = false
    screenGui:Destroy()
end

game:BindToClose(cleanup)
pcall(initialize)

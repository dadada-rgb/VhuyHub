--// Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local LocalizationService = game:GetService("LocalizationService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local StarterGui = game:GetService("StarterGui")
local Camera = Workspace.CurrentCamera

local TextChatService = game:GetService("TextChatService")

local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
if chatWindow then
    chatWindow.Enabled = true
end

--// GUI Setup
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local gui = Instance.new("ScreenGui")
gui.Name = "DhuyxMenu"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = playerGui

--// Config
local Config = {
    CustomPing = nil,
    Buttons = {},
    ESPEnabled = false,
    SpeedEnabled = false,
    FlyEnabled = false,
    AimbotEnabled = false,
    FullbrightEnabled = false,
    NoclipEnabled = false,
    ShiftAmount = 0.5,
    SelectedPlayers = {},
    FlySpeed = 35,
    SpeedAmount = 20,
    clickTpEnabled = false,
    CustomPing = nil,
    RapidFireEnabled = true,
    RapidFireDelay = 0.01,
    MacroLegitEnabled = false,
    AntiLockEnabled = false,
    AntiLockType = "Behind",
    LookAtEnabled = false,
    CsyncOrbitEnabled = false,
    CsyncRandomEnabled = false,
    CsyncRadius = 10,
    CsyncHeight = 5,
    CsyncSpeed = 2,
    RainbowHitEffectEnabled = true,
    AutoWallhopEnabled = false,
    KorAnimEnabled = true,
    SpinbotEnabled = false,
    SpinbotSpeed = 450,
    AutoReloadEnabled = false
}

--// Keybinds
local Keybinds = {}

--// Helpers
local function attachButtonEffects(btn, shrinkPx)
    local orig = btn.Size
    btn.MouseEnter:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(200, 200, 200)}):Play()
    end)
    btn.MouseLeave:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(180, 180, 180)}):Play()
    end)
    btn.MouseButton1Click:Connect(function()
        local s = shrinkPx or 3
        local toSmall = UDim2.new(orig.X.Scale, math.max(0, orig.X.Offset - s), orig.Y.Scale, math.max(0, orig.Y.Offset - s))
        local t1 = TweenService:Create(btn, TweenInfo.new(0.08), {Size = toSmall})
        local t2 = TweenService:Create(btn, TweenInfo.new(0.08), {Size = orig})
        t1:Play(); t1.Completed:Wait(); t2:Play()
    end)
end

local function makeSmoothDraggable(frame, speed)
    speed = speed or 0.2
    local dragging, dragInput, dragStart, startPos
    local function update(input)
        local delta = input.Position - dragStart
        local goal = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        TweenService:Create(frame, TweenInfo.new(speed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = goal}):Play()
    end
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then dragInput = input end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then update(input) end
    end)
end

local function CreateButton(parent, name, callback)
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(1, -10, 0, 30)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.Parent = parent

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0.7, -5, 1, 0)
    button.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    button.BackgroundTransparency = 0.2
    button.TextColor3 = Color3.fromRGB(0, 0, 0)
    button.TextSize = 14
    button.Font = Enum.Font.Gotham
    button.Text = name
    button.Parent = buttonFrame
    Instance.new("UICorner", button).CornerRadius = UDim.new(0, 6)
    attachButtonEffects(button, 3)
    button.MouseButton1Click:Connect(callback)

    local keyBox = Instance.new("TextBox")
    keyBox.Size = UDim2.new(0.3, 0, 1, 0)
    keyBox.Position = UDim2.new(0.7, 5, 0, 0)
    keyBox.BackgroundColor3 = Color3.fromRGB(230, 230, 230)
    keyBox.PlaceholderText = "Key"
    keyBox.Text = ""
    keyBox.TextColor3 = Color3.fromRGB(0, 0, 0)
    keyBox.TextSize = 14
    keyBox.Font = Enum.Font.Gotham
    keyBox.ClearTextOnFocus = false
    keyBox.Parent = buttonFrame
    Instance.new("UICorner", keyBox).CornerRadius = UDim.new(0, 6)

    keyBox:GetPropertyChangedSignal("Text"):Connect(function()
        local text = keyBox.Text:upper()
        if text == "" then
            for k, v in pairs(Keybinds) do
                if v == callback then
                    Keybinds[k] = nil
                    break
                end
            end
        elseif text == "BUTTON" then
            local screenGui = Instance.new("ScreenGui")
            screenGui.IgnoreGuiInset = true
            screenGui.Parent = game:GetService("CoreGui")

            local screenBtn = Instance.new("TextButton")
            screenBtn.Size = UDim2.new(0, 70, 0, 30)
            screenBtn.Position = UDim2.new(0, 100, 0, 300)
            screenBtn.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
            screenBtn.Text = name
            screenBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
            screenBtn.TextSize = 10
            screenBtn.Font = Enum.Font.GothamBold
            screenBtn.Parent = screenGui
            Instance.new("UICorner", screenBtn).CornerRadius = UDim.new(0, 6)
            makeSmoothDraggable(screenBtn, 0.18)
            attachButtonEffects(screenBtn, 3)
            screenBtn.MouseButton1Click:Connect(callback)
        else
            if Enum.KeyCode[text] then
                Keybinds[text] = callback
            end
        end
    end)

    return button
end

--// Toggle Button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 45, 0, 45)
ToggleButton.Position = UDim2.new(0, 15, 0, 250)
ToggleButton.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
ToggleButton.Text = "≡"
ToggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
ToggleButton.TextSize = 20
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Parent = gui
Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 10)
attachButtonEffects(ToggleButton, 5)
makeSmoothDraggable(ToggleButton, 0.18)

--// MainFrame
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 400, 0, 300)
MainFrame.Position = UDim2.new(0.08, 0, 0.2, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
MainFrame.Visible = false
MainFrame.Parent = gui
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 12)
makeSmoothDraggable(MainFrame, 0.2)

-- Shadow
local shadow = Instance.new("ImageLabel", MainFrame)
shadow.Size = UDim2.new(1, 30, 1, 30)
shadow.Position = UDim2.new(0, -15, 0, -15)
shadow.Image = "rbxassetid://1316045217"
shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
shadow.ImageTransparency = 0.4
shadow.ScaleType = Enum.ScaleType.Slice
shadow.SliceCenter = Rect.new(10, 10, 118, 118)
shadow.ZIndex = -1
shadow.BackgroundTransparency = 1

-- Title
local Title = Instance.new("TextLabel", MainFrame)
Title.Size = UDim2.new(1, -10, 0, 35)
Title.Position = UDim2.new(0, 5, 0, 5)
Title.Text = "DhuyxDtuyen"
Title.Font = Enum.Font.GothamBold
Title.TextSize = 18
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1

-- Ping/FPS/Clock
local PingClock = Instance.new("TextLabel")
PingClock.Size = UDim2.new(0, 200, 0, 25)
PingClock.Position = UDim2.new(0, 5, 0, 35)
PingClock.BackgroundTransparency = 1
PingClock.TextColor3 = Color3.fromRGB(200, 200, 200)
PingClock.Font = Enum.Font.Gotham
PingClock.TextSize = 12
PingClock.Parent = MainFrame

task.spawn(function()
    local lastDt = 1/60
    RunService.RenderStepped:Connect(function(dt) lastDt = dt end)
    while task.wait(0.5) do
        local ping = Config.CustomPing or math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local fps = math.clamp(math.floor(1 / (lastDt > 0 and lastDt or 1/240)), 1, 999)
        local timeStr = os.date("%H:%M")
        PingClock.Text = string.format("Ping: %d ms | FPS: %d | %s", ping, fps, timeStr)
    end
end)

local PingBox = Instance.new("TextBox")
PingBox.Size = UDim2.new(0, 80, 0, 25)
PingBox.Position = UDim2.new(1, -85, 0, 5)
PingBox.BackgroundColor3 = Color3.fromRGB(230, 230, 230)
PingBox.BackgroundTransparency = 0.2
PingBox.TextColor3 = Color3.fromRGB(0, 0, 0)
PingBox.TextSize = 14
PingBox.Font = Enum.Font.Gotham
PingBox.PlaceholderText = "Ping (ms)"
PingBox.Text = ""
PingBox.ClearTextOnFocus = false
PingBox.Parent = Title
Instance.new("UICorner", PingBox).CornerRadius = UDim.new(0, 6)

PingBox:GetPropertyChangedSignal("Text"):Connect(function()
    local input = tonumber(PingBox.Text)
    if input and input >= 0 then
        Config.CustomPing = math.clamp(input, 10, 1000)
    else
        Config.CustomPing = nil
    end
end)

--// Tabs
local TabHolder = Instance.new("Frame", MainFrame)
TabHolder.Size = UDim2.new(1, -10, 0, 30)
TabHolder.Position = UDim2.new(0, 5, 0, 65)
TabHolder.BackgroundTransparency = 1
local TabLayout = Instance.new("UIListLayout", TabHolder)
TabLayout.FillDirection = Enum.FillDirection.Horizontal
TabLayout.Padding = UDim.new(0, 5)

local function createTab(name)
    local btn = Instance.new("TextButton", TabHolder)
    btn.Size = UDim2.new(0, 78, 1, 0)
    btn.Text = name
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    btn.TextColor3 = Color3.fromRGB(0, 0, 0)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
    attachButtonEffects(btn, 3)
    return btn
end

local Tab1Btn = createTab("Da Hood")
local Tab2Btn = createTab("Universal")
local Tab3Btn = createTab("Scripts")
local Tab4Btn = createTab("Functions")
local Tab5Btn = createTab("Info")

--// Pages
local Pages = Instance.new("Frame", MainFrame)
Pages.Size = UDim2.new(1, -10, 1, -105)
Pages.Position = UDim2.new(0, 5, 0, 100)
Pages.BackgroundTransparency = 1
Pages.ClipsDescendants = true

local Page1 = Instance.new("Frame", Pages) -- Da Hood
Page1.Size = UDim2.new(1, 0, 1, 0)
Page1.BackgroundTransparency = 1

local Page2 = Instance.new("Frame", Pages) -- Universal
Page2.Size = UDim2.new(1, 0, 1, 0)
Page2.BackgroundTransparency = 1
Page2.Visible = false

local Page3 = Instance.new("Frame", Pages) -- Scripts
Page3.Size = UDim2.new(1, 0, 1, 0)
Page3.BackgroundTransparency = 1
Page3.Visible = false

local Page4 = Instance.new("ScrollingFrame", Pages) -- Functions
Page4.Size = UDim2.new(1, 0, 1, 0)
Page4.BackgroundTransparency = 1
Page4.Visible = false
Page4.ScrollBarThickness = 4
Page4.CanvasSize = UDim2.new(0, 0, 0, 0)

local Page5 = Instance.new("Frame", Pages) -- Info
Page5.Size = UDim2.new(1, 0, 1, 0)
Page5.BackgroundTransparency = 1
Page5.Visible = false

local function switchPage(page)
    Page1.Visible = (page == Page1)
    Page2.Visible = (page == Page2)
    Page3.Visible = (page == Page3)
    Page4.Visible = (page == Page4)
    Page5.Visible = (page == Page5)
end

Tab1Btn.MouseButton1Click:Connect(function() switchPage(Page1) end)
Tab2Btn.MouseButton1Click:Connect(function() switchPage(Page2) end)
Tab3Btn.MouseButton1Click:Connect(function() switchPage(Page3) end)
Tab4Btn.MouseButton1Click:Connect(function() switchPage(Page4) end)
Tab5Btn.MouseButton1Click:Connect(function() switchPage(Page5) end)

--// Page 1 (Da Hood)
local ButtonFrame1 = Instance.new("ScrollingFrame", Page1)
ButtonFrame1.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame1.Position = UDim2.new(0, 5, 0, 10)
ButtonFrame1.BackgroundTransparency = 1
ButtonFrame1.ScrollBarThickness = 4
ButtonFrame1.CanvasSize = UDim2.new(0, 0, 0, 0)

local ButtonLayout1 = Instance.new("UIListLayout", ButtonFrame1)
ButtonLayout1.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout1.Padding = UDim.new(0, 6)
ButtonLayout1:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame1.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout1.AbsoluteContentSize.Y)
end)

local PlayerListFrame = Instance.new("ScrollingFrame", Page1)
PlayerListFrame.Size = UDim2.new(0.5, -5, 1, -20)
PlayerListFrame.Position = UDim2.new(0.5, 0, 0, 10)
PlayerListFrame.BackgroundTransparency = 1
PlayerListFrame.ScrollBarThickness = 4
PlayerListFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

local UIListLayout = Instance.new("UIListLayout", PlayerListFrame)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 4)
UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    PlayerListFrame.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y)
end)

-- Populate PlayerList
local function updatePlayerList()
    for _, child in ipairs(PlayerListFrame:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local playerFrame = Instance.new("Frame", PlayerListFrame)
        playerFrame.Size = UDim2.new(1, -10, 0, 30)
        playerFrame.BackgroundTransparency = 0.2
        playerFrame.BackgroundColor3 = Color3.fromRGB(230, 230, 230)

        local playerLabel = Instance.new("TextLabel", playerFrame)
        playerLabel.Size = UDim2.new(1, -5, 1, 0)
        playerLabel.BackgroundTransparency = 1
        playerLabel.Text = player.DisplayName
        playerLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
        playerLabel.TextSize = 14
        playerLabel.Font = Enum.Font.Gotham
        playerLabel.TextXAlignment = Enum.TextXAlignment.Left

        Instance.new("UICorner", playerFrame).CornerRadius = UDim.new(0, 6)
    end
end

Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)
updatePlayerList()

--// Page 2 (Universal)
local ButtonFrame2Left = Instance.new("ScrollingFrame", Page2)
ButtonFrame2Left.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame2Left.Position = UDim2.new(0, 5, 0, 10)
ButtonFrame2Left.BackgroundTransparency = 1
ButtonFrame2Left.ScrollBarThickness = 4
ButtonFrame2Left.CanvasSize = UDim2.new(0, 0, 0, 0)

local ButtonLayout2Left = Instance.new("UIListLayout", ButtonFrame2Left)
ButtonLayout2Left.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout2Left.Padding = UDim.new(0, 6)
ButtonLayout2Left:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame2Left.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout2Left.AbsoluteContentSize.Y)
end)

local ButtonFrame2Right = Instance.new("ScrollingFrame", Page2)
ButtonFrame2Right.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame2Right.Position = UDim2.new(0.5, 0, 0, 10)
ButtonFrame2Right.BackgroundTransparency = 1
ButtonFrame2Right.ScrollBarThickness = 4
ButtonFrame2Right.CanvasSize = UDim2.new(0, 0, 0, 0)

local ButtonLayout2Right = Instance.new("UIListLayout", ButtonFrame2Right)
ButtonLayout2Right.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout2Right.Padding = UDim.new(0, 6)
ButtonLayout2Right:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame2Right.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout2Right.AbsoluteContentSize.Y)
end)

--// Page 3 (Scripts)
local ScriptHubScroll = Instance.new("ScrollingFrame", Page3)
ScriptHubScroll.Size = UDim2.new(1, -10, 1, -30)
ScriptHubScroll.Position = UDim2.new(0, 5, 0, 5)
ScriptHubScroll.BackgroundTransparency = 1
ScriptHubScroll.ScrollBarThickness = 6
ScriptHubScroll.ScrollingDirection = Enum.ScrollingDirection.Y
ScriptHubScroll.CanvasSize = UDim2.new(0, 0, 0, 0)

local ScriptListLayout = Instance.new("UIListLayout", ScriptHubScroll)
ScriptListLayout.SortOrder = Enum.SortOrder.LayoutOrder
ScriptListLayout.Padding = UDim.new(0, 6)
ScriptListLayout.FillDirection = Enum.FillDirection.Vertical
ScriptListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ScriptHubScroll.CanvasSize = UDim2.new(0, 0, 0, ScriptListLayout.AbsoluteContentSize.Y)
end)

local function CreateScriptItem(name, url)
    local itemFrame = Instance.new("Frame", ScriptHubScroll)
    itemFrame.Size = UDim2.new(1, 0, 0, 35)
    itemFrame.BackgroundTransparency = 0.2
    itemFrame.BackgroundColor3 = Color3.fromRGB(230, 230, 230)

    local nameLabel = Instance.new("TextLabel", itemFrame)
    nameLabel.Size = UDim2.new(0.7, 0, 1, 0)
    nameLabel.Position = UDim2.new(0, 5, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = name
    nameLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left

    local runBtn = Instance.new("TextButton", itemFrame)
    runBtn.Size = UDim2.new(0.3, -10, 1, -4)
    runBtn.Position = UDim2.new(0.7, 5, 0, 2)
    runBtn.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    runBtn.Text = "Run"
    runBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
    runBtn.TextSize = 16
    runBtn.Font = Enum.Font.GothamBold
    Instance.new("UICorner", runBtn).CornerRadius = UDim.new(0, 6)
    attachButtonEffects(runBtn, 3)
    runBtn.MouseButton1Click:Connect(function()
        loadstring(game:HttpGet(url))()
    end)

    Instance.new("UICorner", itemFrame).CornerRadius = UDim.new(0, 6)
    return itemFrame
end

CreateScriptItem("Evade", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/evade")
CreateScriptItem("Murder Mystery 2", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/mm2")
CreateScriptItem("Blade Ball", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/Bladeball")
CreateScriptItem("Doors", "https://raw.githubusercontent.com/DarkDoorsKing/Project/main/Doors.lua")
CreateScriptItem("Emote", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/emote")
CreateScriptItem("Infinite Yield", "https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source")

--// Page 4 (Functions)
local ButtonFrame4 = Instance.new("Frame", Page4)
ButtonFrame4.Size = UDim2.new(1, 0, 1, 0)
ButtonFrame4.BackgroundTransparency = 1
local FuncLayout = Instance.new("UIListLayout", ButtonFrame4)
FuncLayout.SortOrder = Enum.SortOrder.LayoutOrder
FuncLayout.Padding = UDim.new(0, 6)
FuncLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    Page4.CanvasSize = UDim2.new(0, 0, 0, FuncLayout.AbsoluteContentSize.Y)
end)

local autoFarmBtn = CreateButton(ButtonFrame4, "AutoFarm (Off)", function()
    autoFarm = not autoFarm
    autoFarmBtn.Text = "AutoFarm (" .. (autoFarm and "On" or "Off") .. ")"
    if autoFarm then
        task.spawn(autoFarmCoins)
    end
end)

local shootBtn = CreateButton(ButtonFrame4, "Shoot", function()
    task.spawn(shootMurderer)
end)

local espBtn = CreateButton(ButtonFrame4, "ESP (Off)", function()
    espActive = not espActive
    espBtn.Text = "ESP (" .. (espActive and "On" or "Off") .. ")"
    if espActive then
        reloadESP()
    else
        espcontainer:ClearAllGroups()
    end
end)

local autoGunBtn = CreateButton(ButtonFrame4, "AutoGun", function()
    local map = getMap()
    if not map or not map:FindFirstChild("GunDrop") then
        sendNotification("No dropped gun to be teleported to.")
        return
    end
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local previousPosition = hrp.CFrame
        hrp.CFrame = map:FindFirstChild("GunDrop"):GetPivot() + Vector3.new(0, 2, 0)
        LocalPlayer.Backpack.ChildAdded:Wait()
        hrp.CFrame = previousPosition
        sendNotification("Gun picked up.")
    else
        sendNotification("No valid character to teleport.")
    end
end)

local flingMurdererBtn = CreateButton(ButtonFrame4, "Fling Murderer", function()
    local target = findMurderer()
    if target then
        miniFling(target)
    else
        sendNotification("Không tìm thấy murderer.")
    end
end)

local flingSheriffBtn = CreateButton(ButtonFrame4, "Fling Sheriff", function()
    local target = findSheriff()
    if target then
        miniFling(target)
    else
        sendNotification("Không tìm thấy sheriff.")
    end
end)

local killAllBtn = CreateButton(ButtonFrame4, "Kill All", function()
    if findMurderer() ~= LocalPlayer then
        sendNotification("You're not murderer.")
        return
    end
    if not LocalPlayer.Character:FindFirstChild("Knife") then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if LocalPlayer.Backpack:FindFirstChild("Knife") then
            hum:EquipTool(LocalPlayer.Backpack:FindFirstChild("Knife"))
            task.wait(0.1)
        else
            sendNotification("You don't have the knife..?")
            return
        end
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetPart = player.Character:FindFirstChild("HumanoidRootPart")
            targetPart.Anchored = true
            targetPart.CFrame = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame + LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame.LookVector * 1
            task.wait(0.05)
        end
    end
    local args = { [1] = "Slash" }
    LocalPlayer.Character.Knife.Stab:FireServer(unpack(args))
    task.wait(0.1)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character:FindFirstChild("HumanoidRootPart").Anchored = false
        end
    end
    sendNotification("Auto Kill All executed.")
end)

local tpLobbyBtn = CreateButton(ButtonFrame4, "TP Lobby", function()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart")
    hrp.CFrame = CFrame.new(-107, 152, 41)
end)

--// Page 5 (Info)
local Avatar = Instance.new("ImageLabel", Page5)
Avatar.Size = UDim2.new(0, 80, 0, 80)
Avatar.Position = UDim2.new(0, 10, 0, 10)
Avatar.BackgroundTransparency = 1
Avatar.Image = "rbxthumb://type=AvatarHeadShot&id="..LocalPlayer.UserId.."&w=150&h=150"

local InfoPanel = Instance.new("Frame", Page5)
InfoPanel.Position = UDim2.new(0, 100, 0, 10)
InfoPanel.Size = UDim2.new(1, -110, 1, -20)
InfoPanel.BackgroundTransparency = 1
InfoPanel.ClipsDescendants = true

local InfoLayout = Instance.new("UIListLayout", InfoPanel)
InfoLayout.Padding = UDim.new(0, 6)
InfoLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
InfoLayout.VerticalAlignment = Enum.VerticalAlignment.Top

local function mkLine()
    local l = Instance.new("TextLabel")
    l.Size = UDim2.new(1, -10, 0, 22)
    l.BackgroundTransparency = 1
    l.Font = Enum.Font.Gotham
    l.TextSize = 14
    l.TextColor3 = Color3.fromRGB(200, 200, 200)
    l.TextXAlignment = Enum.TextXAlignment.Left
    l.TextWrapped = false
    l.ClipsDescendants = true
    l.Parent = InfoPanel
    return l
end

local lineDisplay = mkLine()
local lineUser = mkLine()
local lineFPS = mkLine()
local lineTime = mkLine()
local lineCountry = mkLine()
local lineFriends = mkLine()

lineDisplay.Text = "Display Name : "..LocalPlayer.DisplayName
lineUser.Text = "Username     : @"..LocalPlayer.Name

task.spawn(function()
    local c = "Unknown"
    pcall(function()
        c = LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer) or "Unknown"
    end)
    lineCountry.Text = "Country      : "..c
end)

task.spawn(function()
    local ok, list = pcall(function() return Players:GetFriendsOnline() end)
    local count = (ok and type(list)=="table") and #list or 0
    lineFriends.Text = "Friends Online: "..count
end)

task.spawn(function()
    local lastDt = 1/60
    RunService.RenderStepped:Connect(function(dt) lastDt = dt end)
    while task.wait(0.5) do
        local fps = math.clamp(math.floor(1 / (lastDt > 0 and lastDt or 1/240)), 1, 999)
        lineFPS.Text = "FPS          : "..fps
        lineTime.Text = "Time         : "..os.date("%H:%M")
    end
end)

--// Toggle open/close
ToggleButton.MouseButton1Click:Connect(function()
    MainFrame.Visible = not MainFrame.Visible
end)

--// Keybinds
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    local key = input.KeyCode.Name:upper()
    if Keybinds[key] then
        Keybinds[key]()
    end
end)

function sendNotification(title, text, duration)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title or "DhuyxDtuyen",
            Text = text or "",
            Duration = duration or 3
        })
    end)
end

local autoSelect = false
local tbEnabled = true
local fovRadius = 20
local Player = nil
local camera = Workspace.CurrentCamera
local clickTpTool = nil
local savedWaypoint = nil
local noclipConnection = nil
local Keybinds = {} 

local oldLighting = {
    Brightness = Lighting.Brightness,
    GlobalShadows = Lighting.GlobalShadows,
    FogEnd = Lighting.FogEnd,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    ClockTime = Lighting.ClockTime
}

local blur = Instance.new("BlurEffect")
blur.Size = 20
blur.Parent = Lighting

local introGui = Instance.new("ScreenGui")
introGui.Name = "VhuyIntroGui"
introGui.IgnoreGuiInset = true
introGui.ResetOnSpawn = false
introGui.DisplayOrder = 99999
introGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local bg = Instance.new("Frame")
bg.Size = UDim2.new(1, 0, 1, 0)
bg.BackgroundColor3 = Color3.new(0, 0, 0)
bg.BackgroundTransparency = 1
bg.Parent = introGui

local title = Instance.new("TextLabel")
title.AnchorPoint = Vector2.new(0.5, 0.5)
title.Position = UDim2.new(0.5, 0, 0.5, 0)
title.Size = UDim2.new(0, 400, 0, 120)
title.Text = "DhuyxDtuyen"
title.Font = Enum.Font.GothamBlack
title.TextColor3 = Color3.fromRGB(55, 55, 55)
title.TextScaled = true
title.TextTransparency = 1
title.BackgroundTransparency = 1
title.Parent = introGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = title

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(55, 55, 55)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(230, 230, 230))
}
gradient.Rotation = 45
gradient.Parent = title

TweenService:Create(title, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 0}):Play()
TweenService:Create(bg, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 0.4}):Play()

task.delay(4, function()
    TweenService:Create(title, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 1}):Play()
    TweenService:Create(bg, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
    task.delay(1.5, function()
        introGui:Destroy()
        blur:Destroy()
    end)
end)

espButton = CreateButton(ButtonFrame1, "ESP: OFF", function()
    Config.ESPEnabled = not Config.ESPEnabled
    espButton.Text = "ESP: " .. (Config.ESPEnabled and "ON" or "OFF")
    sendNotification("ESP", Config.ESPEnabled and "ON" or "OFF")
end)

speedButton = CreateButton(ButtonFrame1, "Speed: OFF", function()
    Config.SpeedEnabled = not Config.SpeedEnabled
    speedButton.Text = "Speed: " .. (Config.SpeedEnabled and "ON" or "OFF")
    sendNotification("SPEED", Config.SpeedEnabled and "ON" or "OFF")
end)

flyButton = CreateButton(ButtonFrame1, "Fly: OFF", function()
    Config.FlyEnabled = not Config.FlyEnabled
    flyButton.Text = "Fly: " .. (Config.FlyEnabled and "ON" or "OFF")
    sendNotification("FLY", Config.FlyEnabled and "ON" or "OFF")
end)

aimbotButton = CreateButton(ButtonFrame1, "Aimlock: OFF", function()
    Config.AimbotEnabled = not Config.AimbotEnabled
    aimbotButton.Text = "Aimlock: " .. (Config.AimbotEnabled and "ON" or "OFF")
    sendNotification("AIMLOCK", Config.AimbotEnabled and "ON" or "OFF")
end)

local utility = {}
utility.get_gun = function()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, tool in next, char:GetChildren() do
        if tool:IsA("Tool") and (tool:FindFirstChild("Ammo") or tool:FindFirstChild("AmmoCount") or tool:FindFirstChild("GunScript")) then
            return tool
        end
    end
end
utility.rapid = function(tool)
    tool:Activate()
end

local isFiring = false
UserInputService.InputBegan:Connect(function(i, gp)
    if gp then return end
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        local gun = utility.get_gun()
        if Config.RapidFireEnabled and gun and not isFiring then
            isFiring = true
            task.spawn(function()
                while isFiring and Config.RapidFireEnabled do
                    utility.rapid(gun)
                    task.wait(Config.RapidFireDelay)
                end
            end)
        end
    end
end)
UserInputService.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        isFiring = false
    end
end)

local Orginal = {}
RunService.RenderStepped:Connect(function()
    if not Config.RapidFireEnabled then return end
    local char = LocalPlayer.Character
    if not char then return end

    local tool = char:FindFirstChildOfClass("Tool")
    if tool and (tool:FindFirstChild("GunScript") or tool:FindFirstChild("Ammo") or tool:FindFirstChild("AmmoCount")) then
        for _, connection in ipairs(getconnections(tool.Activated)) do
            local func = connection.Function
            if func then
                local funcInfo = debug.getinfo(func)
                for i = 1, funcInfo.nups do
                    local c, n = debug.getupvalue(func, i)
                    if type(c) == "number" then
                        if not Orginal[i] then
                            Orginal[i] = c
                        end
                        debug.setupvalue(func, i, Config.RapidFireEnabled and 0.0000000001 or Orginal[i])
                    end
                end
            end
        end
    end
end)

rapidFireButton = CreateButton(ButtonFrame1, "Rapid Fire: " .. (Config.RapidFireEnabled and "ON" or "OFF"), function()
    Config.RapidFireEnabled = not Config.RapidFireEnabled
    rapidFireButton.Text = "Rapid Fire: " .. (Config.RapidFireEnabled and "ON" or "OFF")
    sendNotification("Rapid Fire", Config.RapidFireEnabled and "Enabled" or "Disabled")
end)

macroLegitButton = CreateButton(ButtonFrame1, "Macro Legit: " .. (Config.MacroLegitEnabled and "ON" or "OFF"), function()
    Config.MacroLegitEnabled = not Config.MacroLegitEnabled
    macroLegitButton.Text = "Macro Legit: " .. (Config.MacroLegitEnabled and "ON" or "OFF")
    sendNotification("Macro Legit", Config.MacroLegitEnabled and "Enabled" or "Disabled")

    if Config.MacroLegitEnabled then
        task.spawn(function()
            repeat
                game:GetService("RunService").Heartbeat:Wait()
                game:GetService("VirtualInputManager"):SendMouseWheelEvent(0.1, 0.1, true, game)
                game:GetService("RunService").Heartbeat:Wait()
                game:GetService("VirtualInputManager"):SendMouseWheelEvent(0.1, 0.1, false, game)
                game:GetService("RunService").Heartbeat:Wait()
            until not Config.MacroLegitEnabled
        end)
    end
end)

local antiLockModes = {
    Behind = true, Down = true, ForWard = true,
    Left = true, One = true, Right = true,
    Up = true, Zero = true
}

antiLockButton = CreateButton(ButtonFrame1, "AntiLock: " .. (Config.AntiLockEnabled and "ON" or "OFF"), function()
    Config.AntiLockEnabled = not Config.AntiLockEnabled
    antiLockButton.Text = "AntiLock: " .. (Config.AntiLockEnabled and "ON" or "OFF")
    sendNotification("AntiLock", Config.AntiLockEnabled and "Enabled" or "Disabled")
end)

local modeBox = Instance.new("TextBox")
modeBox.Size = UDim2.new(1, 0, 0, 20)
modeBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
modeBox.TextColor3 = Color3.new(1, 1, 1)
modeBox.Font = Enum.Font.GothamBold
modeBox.TextSize = 12
modeBox.ClearTextOnFocus = false
modeBox.PlaceholderText = "Enter mode (default Behind)"
modeBox.Text = Config.AntiLockType
Instance.new("UICorner", modeBox).CornerRadius = UDim.new(0, 4)
modeBox.Parent = ButtonFrame1

modeBox.FocusLost:Connect(function()
    local input = modeBox.Text
    if input == "" then
        Config.AntiLockType = "Behind"
    elseif antiLockModes[input] then
        Config.AntiLockType = input
    else
        sendNotification("AntiLock", "Invalid mode! Keeping: " .. Config.AntiLockType)
        modeBox.Text = Config.AntiLockType
        return
    end
    sendNotification("AntiLock", "Type set to: " .. Config.AntiLockType)
end)

if _G.__vhuyhub_antilock_conn then
    _G.__vhuyhub_antilock_conn:Disconnect()
end

_G.__vhuyhub_antilock_conn = RunService.Heartbeat:Connect(function()
    if not Config.AntiLockEnabled then return end

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local dir = Vector3.new(0, 0, -1)
    local t = Config.AntiLockType
    if     t == "Behind"  then dir = Vector3.new(0,  0, -1)
    elseif t == "Down"    then dir = Vector3.new(0, -1,  0)
    elseif t == "ForWard" then dir = Vector3.new(0,  0,  1)
    elseif t == "Left"    then dir = Vector3.new(-1, 0,  0)
    elseif t == "One"     then dir = Vector3.new(1,  1,  1)
    elseif t == "Right"   then dir = Vector3.new(1,  0,  0)
    elseif t == "Up"      then dir = Vector3.new(0,  1,  0)
    elseif t == "Zero"    then dir = Vector3.new(0,  0,  0)
    end

    local oldVel = hrp.Velocity
    hrp.Velocity = dir * (2^16)
    RunService.RenderStepped:Wait()
    if hrp and hrp.Parent then
        hrp.Velocity = oldVel
    end
end)

local function getMyHumanoid()
    local char = LocalPlayer.Character
    if not char then return nil,nil,nil end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    return char, hum, hrp
end

local function getClosestSelected()
    local _, _, myHRP = getMyHumanoid()
    if not myHRP then return end
    
    local myPos, closest, minDist = myHRP.Position, nil, math.huge
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local hrp = Players:FindFirstChild(name)
                and Players[name].Character
                and Players[name].Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (myPos - hrp.Position).Magnitude
                if dist < minDist then
                    closest, minDist = Players[name], dist
                end
            end
        end
    end
    return closest
end

local lastTargetName, lastNotify = nil, 0

RunService.Heartbeat:Connect(function()
    if not (Config.CsyncOrbitEnabled or Config.CsyncRandomEnabled) then
        Config.LookAtEnabled = false
        return
    end
    
    Config.LookAtEnabled = true
    local char, hum, hrp = getMyHumanoid()
    if not (hum and hrp) then return end
    hum.AutoRotate = false

    local targetPlr = getClosestSelected()
    if not targetPlr then return end

    local thrp = targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart")
    if not thrp then return end

    local myPos = hrp.Position
    local tPos = thrp.Position
    local facePos = Vector3.new(tPos.X, myPos.Y, tPos.Z)

    hrp.CFrame = hrp.CFrame:Lerp(CFrame.lookAt(myPos, facePos), 0.35)
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.defer(function()
        local _, hum = getMyHumanoid()
        if hum then hum.AutoRotate = true end
    end)
end)

autoArmorEnabled = false

autoArmorButton = CreateButton(ButtonFrame1, "Auto Armor: OFF", function()
    autoArmorEnabled = not autoArmorEnabled
    autoArmorButton.Text = "Auto Armor: " .. (autoArmorEnabled and "ON" or "OFF")
    sendNotification("Auto Armor", autoArmorEnabled and "Enabled" or "Disabled")
end)

local cloneref = getgenv().cloneref or function(...) return ... end
local fireclickdetector = getgenv().fireclickdetector or function(...) return nil end
local GameReference = cloneref(game)

if not GameReference:IsLoaded() then game.Loaded:Wait() end

local Workspace = cloneref(game:GetService("Workspace"))
local RunService = cloneref(game:GetService("RunService"))
local Players = cloneref(game:GetService("Players"))

local LocalPlayer = Players.LocalPlayer
local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local LocalHumanoid = LocalCharacter:FindFirstChildOfClass("Humanoid") or LocalCharacter:WaitForChild("Humanoid", 1e9)
local LocalRootPart = LocalHumanoid and LocalHumanoid.RootPart or LocalCharacter:WaitForChild("HumanoidRootPart", 1e9)

local BuyMaxDistance = 1000

LocalPlayer.CharacterAdded:Connect(function(Character)
    LocalCharacter = Character
    LocalHumanoid = LocalCharacter:FindFirstChildOfClass("Humanoid") or LocalCharacter:WaitForChild("Humanoid", 1e9)
    LocalRootPart = LocalHumanoid and LocalHumanoid.RootPart or LocalCharacter:WaitForChild("HumanoidRootPart", 1e9)
end)

RunService.PostSimulation:Connect(function()
    if not autoArmorEnabled then return end
    if not LocalCharacter or not LocalHumanoid or not LocalRootPart then return end

    local Ignored = Workspace:FindFirstChild("Ignored") or Workspace:FindFirstChild("MAP") or Workspace:FindFirstChild("Blacklisted")
    if Ignored then
        local Shop = Ignored:FindFirstChild("Shop") or Ignored:FindFirstChild("Shops") or Ignored:FindFirstChild("Pads") or Ignored:FindFirstChild("BuyPads") or Ignored:FindFirstChild("Bought")
        if Shop then
            for _, Child in ipairs(Shop:GetChildren()) do
                if Child.Name:lower():find("armor") and Child:IsA("Model") and Child:FindFirstChildOfClass("ClickDetector") then
                    local Head = Child:FindFirstChild("Head") or Child:FindFirstChild("Part")
                    if Head and Head:IsA("BasePart") and (Head.Position - LocalRootPart.Position).Magnitude <= BuyMaxDistance then
                        fireclickdetector(Child:FindFirstChildOfClass("ClickDetector"))
                    end
                end
            end
        end
    end
end)

autoReloadButton = CreateButton(ButtonFrame1, "Auto Reload: " .. (Config.AutoReloadEnabled and "ON" or "OFF"), function()
    Config.AutoReloadEnabled = not Config.AutoReloadEnabled
    autoReloadButton.Text = "Auto Reload: " .. (Config.AutoReloadEnabled and "ON" or "OFF")
    sendNotification("Auto Reload", Config.AutoReloadEnabled and "Enabled" or "Disabled")
end)

if _G.__vhuyhub_autoreload_conn then
    _G.__vhuyhub_autoreload_conn:Disconnect()
end

_G.__vhuyhub_autoreload_conn = RunService.Heartbeat:Connect(function()
    if not Config.AutoReloadEnabled then return end

    local char = LocalPlayer.Character
    local tool = char and char:FindFirstChildWhichIsA("Tool")
    if not tool then return end

    local ammoVal = tool:FindFirstChild("Ammo") or tool:FindFirstChild("AmmoCount")
    if ammoVal and ammoVal.Value <= 0 then
        game:GetService("ReplicatedStorage").MainEvent:FireServer("Reload", tool)
        task.wait(1)
    end
end)

triggerBotButton = CreateButton(ButtonFrame1, "TriggerBot: " .. (tbEnabled and "ON" or "OFF"), function()
    tbEnabled = not tbEnabled
    triggerBotButton.Text = "TriggerBot: " .. (tbEnabled and "ON" or "OFF")
    sendNotification("TRIGGERBOT", tbEnabled and "ON" or "OFF")
end)

tpAndStompButton = CreateButton(ButtonFrame1, "TP Player", function()
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position
    if not myPos then return end

    local closestPlayer, minDist = nil, math.huge

    for name, selected in pairs(Config.SelectedPlayers) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local pos = plr.Character.HumanoidRootPart.Position
                local dist = (myPos - pos).Magnitude
                if dist < minDist then
                    closestPlayer = plr
                    minDist = dist
                end
            end
        end
    end

    if closestPlayer then
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local pos = closestPlayer.Character.HumanoidRootPart.Position
            root.CFrame = CFrame.new(pos + Vector3.new(0, 0, 0))
        end
    end
end)

local function isKO(plr)
    local char = plr and plr.Character
    local be = char and char:FindFirstChild("BodyEffects")
    local ko = be and be:FindFirstChild("K.O")
    return ko and ko.Value
end

local function isGrabbed(plr)
    local char = plr and plr.Character
    return char and char:FindFirstChild("GRABBING_CONSTRAINT")
end

local function getClosestSelected()
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local closest, minDist
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local hrp = plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp and not isKO(plr) and not isGrabbed(plr) then
                local dist = (myHRP.Position - hrp.Position).Magnitude
                if not minDist or dist < minDist then
                    closest, minDist = plr, dist
                end
            end
        end
    end
    return closest
end

local function getNextTarget(currentTarget)
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local candidates = {}
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr ~= currentTarget and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(candidates, plr)
            end
        end
    end
    table.sort(candidates, function(a, b)
        local ha = a.Character and a.Character:FindFirstChild("HumanoidRootPart")
        local hb = b.Character and b.Character:FindFirstChild("HumanoidRootPart")
        if not ha or not hb then return false end
        return (myHRP.Position - ha.Position).Magnitude < (myHRP.Position - hb.Position).Magnitude
    end)
    return candidates[1]
end

csyncRandomButton = CreateButton(ButtonFrame1, "Csync Random: " .. (Config.CsyncRandomEnabled and "ON" or "OFF"), function()
    Config.CsyncRandomEnabled = not Config.CsyncRandomEnabled
    if Config.CsyncRandomEnabled then
        Config.AimbotEnabled = true
    end
    csyncRandomButton.Text = "Csync Random: " .. (Config.CsyncRandomEnabled and "ON" or "OFF")
    sendNotification("Csync Random", Config.CsyncRandomEnabled and "Enabled" or "Disabled")
end)

csyncOrbitButton = CreateButton(ButtonFrame1, "Csync Orbit: " .. (Config.CsyncOrbitEnabled and "ON" or "OFF"), function()
    Config.CsyncOrbitEnabled = not Config.CsyncOrbitEnabled
    if Config.CsyncOrbitEnabled then
        Config.AimbotEnabled = true
    end
    csyncOrbitButton.Text = "Csync Orbit: " .. (Config.CsyncOrbitEnabled and "ON" or "OFF")
    sendNotification("Csync Orbit", Config.CsyncOrbitEnabled and "Enabled" or "Disabled")
end)

local boxFrame = Instance.new("Frame")
boxFrame.Size = UDim2.new(1, 0, 0, 40)
boxFrame.BackgroundTransparency = 1
boxFrame.Parent = ButtonFrame1

local function createLabeledBox(parent, labelText, default, onChange, pos)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1/3 - 0.02, 0, 1, 0)
    container.Position = pos
    container.BackgroundTransparency = 1
    container.Parent = parent

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 10)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextSize = 10
    label.TextColor3 = Color3.fromRGB(180, 180, 180)
    label.Font = Enum.Font.Gotham
    label.Parent = container

    local tb = Instance.new("TextBox")
    tb.Size = UDim2.new(1, 0, 0, 20)
    tb.Position = UDim2.new(0, 0, 0, 12)
    tb.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    tb.TextColor3 = Color3.new(1, 1, 1)
    tb.Text = tostring(default)
    tb.PlaceholderText = labelText
    tb.ClearTextOnFocus = false
    tb.Font = Enum.Font.GothamBold
    tb.TextSize = 12
    tb.Parent = container
    Instance.new("UICorner", tb).CornerRadius = UDim.new(0, 4)

    tb.FocusLost:Connect(function()
        local num = tonumber(tb.Text)
        if num then
            onChange(num)
        else
            tb.Text = tostring(default)
        end
    end)
end

createLabeledBox(boxFrame, "Radius", Config.CsyncRadius, function(v) Config.CsyncRadius = v end, UDim2.new(0, 0, 0, 0))
createLabeledBox(boxFrame, "Height", Config.CsyncHeight, function(v) Config.CsyncHeight = v end, UDim2.new(1/3, 0, 0, 0))
createLabeledBox(boxFrame, "Speed",  Config.CsyncSpeed,  function(v) Config.CsyncSpeed  = v end, UDim2.new(2/3, 0, 0, 0))

local currentTarget = nil
local csyncPaused = false

if _G.VHUB_CSYNC_LOOP then _G.VHUB_CSYNC_LOOP:Disconnect() end
_G.VHUB_CSYNC_LOOP = RunService.Heartbeat:Connect(function()
    if not currentTarget or not currentTarget.Parent then
        currentTarget = getClosestSelected()
    end

    if csyncPaused then
        if currentTarget then
            csyncPaused = false
        else
            return
        end
    end

    if not currentTarget then
        csyncPaused = true
        return
    end

    if isKO(currentTarget) or isGrabbed(currentTarget) then
        local nextTarget = getNextTarget(currentTarget)
        if nextTarget then
            currentTarget = nextTarget
        else
            csyncPaused = true
            return
        end
    end

    if not csyncPaused then
        local hrp = currentTarget.Character and currentTarget.Character:FindFirstChild("HumanoidRootPart")
        local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp or not myHRP then return end

        if Config.CsyncOrbitEnabled then
            local t = tick() * Config.CsyncSpeed
            local pos = hrp.Position + Vector3.new(
                math.cos(t) * Config.CsyncRadius,
                Config.CsyncHeight,
                math.sin(t) * Config.CsyncRadius
            )
            myHRP.CFrame = CFrame.new(pos, hrp.Position)
        elseif Config.CsyncRandomEnabled then
            local offset = Vector3.new(
                math.random(-Config.CsyncRadius, Config.CsyncRadius),
                Config.CsyncHeight,
                math.random(-Config.CsyncRadius, Config.CsyncRadius)
            )
            myHRP.CFrame = CFrame.new(hrp.Position + offset, hrp.Position)
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if Config.CsyncOrbitEnabled or Config.CsyncRandomEnabled then
        Config.CsyncOrbitEnabled = false
        Config.CsyncRandomEnabled = false
        csyncOrbitButton.Text = "Csync Orbit: OFF"
        csyncRandomButton.Text = "Csync Random: OFF"
        sendNotification("Csync", "Đã tắt vì bạn chết")
    end
end)

local customFovEnabled = false
local defaultFov = Workspace.CurrentCamera.FieldOfView

customFovButton = CreateButton(ButtonFrame2Left, "Custom FOV: OFF", function()
    customFovEnabled = not customFovEnabled
    customFovButton.Text = "Custom FOV: " .. (customFovEnabled and "ON" or "OFF")

    if customFovEnabled then
        local num = tonumber(fovBox.Text)
        if num and num >= 40 and num <= 120 then
            Workspace.CurrentCamera.FieldOfView = num
            sendNotification("Custom FOV", "Đã đặt FOV thành " .. num)
        else
            sendNotification("Custom FOV", "Hãy nhập giá trị 40-120 vào ô FOV")
        end
    else
        Workspace.CurrentCamera.FieldOfView = defaultFov
    end
end)

local fovBox = Instance.new("TextBox")
fovBox.Size = UDim2.new(1, -10, 0, 25)
fovBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
fovBox.BackgroundTransparency = 0.2
fovBox.TextColor3 = Color3.fromRGB(0, 0, 0)
fovBox.TextSize = 14
fovBox.Font = Enum.Font.Gotham
fovBox.PlaceholderText = "Nhập FOV (mặc định: "..defaultFov..")"
fovBox.ClearTextOnFocus = false
fovBox.Parent = ButtonFrame2Left
Instance.new("UICorner", fovBox).CornerRadius = UDim.new(0, 6)

fovBox:GetPropertyChangedSignal("Text"):Connect(function()
    if customFovEnabled then
        local num = tonumber(fovBox.Text)
        if num and num >= 40 and num <= 120 then
            Workspace.CurrentCamera.FieldOfView = num
            sendNotification("Custom FOV", "Đã đặt FOV thành " .. num)
        end
    end
end)

getgenv().RightUpperLegAccessories = {
    {id = 18457575895},
}
getgenv().KorAnimDelay = 1

local function hideRightLegAndAddAccessories(character)
    local rightUpperLeg = character:FindFirstChild("RightUpperLeg")
    if rightUpperLeg then
        rightUpperLeg.Transparency = 1

        local rightLowerLeg = character:FindFirstChild("RightLowerLeg")
        local rightFoot = character:FindFirstChild("RightFoot")
        if rightLowerLeg then rightLowerLeg:Destroy() end
        if rightFoot then rightFoot:Destroy() end

        for _, accessoryData in ipairs(getgenv().RightUpperLegAccessories) do
            local accessory = game:GetObjects("rbxassetid://" .. tostring(accessoryData.id))[1]
            if accessory then
                accessory.Parent = game.Workspace
                local handle = accessory:FindFirstChild("Handle")
                if handle then
                    handle.CFrame = rightUpperLeg.CFrame
                    local weld = Instance.new("Weld")
                    weld.Part0 = handle
                    weld.Part1 = rightUpperLeg
                    weld.C0 = CFrame.new(0, -0.12, 0)
                    weld.Parent = handle
                    accessory.Parent = character
                end
            end
        end
    end
end

local function applyKorAnim(character)
    task.wait(getgenv().KorAnimDelay)
    hideRightLegAndAddAccessories(character)
end

game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    applyKorAnim(char)
end)

if game.Players.LocalPlayer.Character then
    applyKorAnim(game.Players.LocalPlayer.Character)
end

game:GetService("RunService").Stepped:Connect(function()
    if not getgenv().KorAnimEnabled then return end
    local char = game.Players.LocalPlayer.Character
    if char and char:FindFirstChild("Animate") then
        local anim = char.Animate
        anim.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
        anim.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=10921242013"
        anim.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
    end
end)

fullbrightButton = CreateButton(ButtonFrame2Left, "Fullbright: OFF", function()
    Config.FullbrightEnabled = not Config.FullbrightEnabled
    if Config.FullbrightEnabled then
        Lighting.Brightness = 2
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 999999
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
        Lighting.ClockTime = 12
    else
        Lighting.Brightness = oldLighting.Brightness
        Lighting.GlobalShadows = oldLighting.GlobalShadows
        Lighting.FogEnd = oldLighting.FogEnd
        Lighting.Ambient = oldLighting.Ambient
        Lighting.OutdoorAmbient = oldLighting.OutdoorAmbient
        Lighting.ClockTime = oldLighting.ClockTime
    end
    fullbrightButton.Text = "Fullbright: " .. (Config.FullbrightEnabled and "ON" or "OFF")
    sendNotification("FULLBRIGHT", Config.FullbrightEnabled and "ON" or "OFF")
end)

autoWallhopButton = CreateButton(ButtonFrame2Left, "Auto Wallhop: " .. (Config.AutoWallhopEnabled and "ON" or "OFF"), function()
    Config.AutoWallhopEnabled = not Config.AutoWallhopEnabled
    autoWallhopButton.Text = "Auto Wallhop: " .. (Config.AutoWallhopEnabled and "ON" or "OFF")
    sendNotification("Auto Wallhop", Config.AutoWallhopEnabled and "Enabled" or "Disabled")
end)

local character, humanoid, rootPart

local function updateCharacterRefs()
    character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

updateCharacterRefs()
LocalPlayer.CharacterAdded:Connect(updateCharacterRefs)

local function isWallInFront()
    if not rootPart then return false end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local origin = rootPart.Position + Vector3.new(0, 2, 0)
    local direction = rootPart.CFrame.LookVector * 2
    local result = Workspace:Raycast(origin, direction, raycastParams)

    return result and result.Instance ~= nil
end

local isPerformingWallHop = false
local function performWallHop()
    if not Config.AutoWallhopEnabled or isPerformingWallHop or not humanoid or not rootPart then return end
    isPerformingWallHop = true

    while Config.AutoWallhopEnabled and isWallInFront() do
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        rootPart.AssemblyLinearVelocity = Vector3.new(0, 60, 0)
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(-35), 0)
        task.wait(0.5)
    end

    isPerformingWallHop = false
end

RunService.Heartbeat:Connect(function()
    if Config.AutoWallhopEnabled then
        performWallHop()
    end
end)

local function createSkibidiRedRizz(character)
    local attachment = Instance.new("Attachment")
    attachment.Name = "SkibidiAura"
    attachment.Parent = character and (character:FindFirstChild("LowerTorso") or character:FindFirstChild("HumanoidRootPart"))

    local HealingWave1 = Instance.new("ParticleEmitter")
    HealingWave1.Name = "Healing Wave 1"
    HealingWave1.Lifetime = NumberRange.new(1.5, 1.5)
    HealingWave1.SpreadAngle = Vector2.new(10, -10)
    HealingWave1.LockedToPart = true
    HealingWave1.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.1702454, 0.7),
        NumberSequenceKeypoint.new(0.2254601, 0.03125),
        NumberSequenceKeypoint.new(0.2852761, 0),
        NumberSequenceKeypoint.new(0.702454, 0),
        NumberSequenceKeypoint.new(0.8374233, 0.9125),
        NumberSequenceKeypoint.new(1, 1)
    })
    HealingWave1.LightEmission = 0.4
    HealingWave1.VelocitySpread = 10
    HealingWave1.Speed = NumberRange.new(3, 6)
    HealingWave1.Brightness = 10
    HealingWave1.Color = ColorSequence.new(Color3.new(1,1,1))
    HealingWave1.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 3.0624998),
        NumberSequenceKeypoint.new(0.6420546, 1.9999999),
        NumberSequenceKeypoint.new(1, 0.7499999)
    })
    HealingWave1.Rate = 20
    HealingWave1.Texture = "rbxassetid://8047533775"
    HealingWave1.RotSpeed = NumberRange.new(200, 400)
    HealingWave1.Rotation = NumberRange.new(-180, 180)
    HealingWave1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    HealingWave1.Parent = attachment

    local HealingWave2 = Instance.new("ParticleEmitter")
    HealingWave2.Name = "Healing Wave 2"
    HealingWave2.Lifetime = NumberRange.new(1.5, 1.5)
    HealingWave2.SpreadAngle = Vector2.new(10, -10)
    HealingWave2.LockedToPart = true
    HealingWave2.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.2254601, 0.03125),
        NumberSequenceKeypoint.new(0.6288344, 0.25625),
        NumberSequenceKeypoint.new(0.8374233, 0.9125),
        NumberSequenceKeypoint.new(1, 1)
    })
    HealingWave2.LightEmission = 1
    HealingWave2.VelocitySpread = 10
    HealingWave2.Speed = NumberRange.new(3, 5)
    HealingWave2.Brightness = 10
    HealingWave2.Color = ColorSequence.new(Color3.new(1,1,1))
    HealingWave2.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 3.125),
        NumberSequenceKeypoint.new(0.4165329, 1.3749999),
        NumberSequenceKeypoint.new(1, 0.9375)
    })
    HealingWave2.Rate = 20
    HealingWave2.Texture = "rbxassetid://8047796070"
    HealingWave2.RotSpeed = NumberRange.new(100, 300)
    HealingWave2.Rotation = NumberRange.new(-180, 180)
    HealingWave2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    HealingWave2.Parent = attachment

    local Sparks = Instance.new("ParticleEmitter")
    Sparks.Name = "Sparks"
    Sparks.Lifetime = NumberRange.new(0.5, 2)
    Sparks.SpreadAngle = Vector2.new(180, -180)
    Sparks.LightEmission = 1
    Sparks.Drag = 3
    Sparks.VelocitySpread = 180
    Sparks.Speed = NumberRange.new(5, 15)
    Sparks.Brightness = 10
    Sparks.Color = ColorSequence.new(Color3.new(1,1,1))
    Sparks.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.14687, 0.4374999),
        NumberSequenceKeypoint.new(1, 0)
    })
    Sparks.Acceleration = Vector3.new(0, 3, 0)
    Sparks.ZOffset = -1
    Sparks.Rate = 40
    Sparks.Texture = "rbxassetid://8611887361"
    Sparks.RotSpeed = NumberRange.new(-30, 30)
    Sparks.Orientation = Enum.ParticleOrientation.VelocityParallel
    Sparks.Parent = attachment

    local StarSparks = Instance.new("ParticleEmitter")
    StarSparks.Name = "Star Sparks"
    StarSparks.Lifetime = NumberRange.new(1.5, 1.5)
    StarSparks.SpreadAngle = Vector2.new(180, -180)
    StarSparks.LightEmission = 1
    StarSparks.Drag = 3
    StarSparks.VelocitySpread = 180
    StarSparks.Speed = NumberRange.new(5, 10)
    StarSparks.Brightness = 10
    StarSparks.Color = ColorSequence.new(Color3.new(1,1,1))
    StarSparks.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.1492777, 0.6874996),
        NumberSequenceKeypoint.new(1, 0)
    })
    StarSparks.Acceleration = Vector3.new(0, 3, 0)
    StarSparks.ZOffset = 2
    StarSparks.Texture = "rbxassetid://8611887703"
    StarSparks.RotSpeed = NumberRange.new(-30, 30)
    StarSparks.Rotation = NumberRange.new(-30, 30)
    StarSparks.Parent = attachment

    return attachment
end

local function rainbowColor()
    local t = tick() % 5 / 5
    return Color3.fromHSV(t, 1, 1)
end

rainbowHitButton = CreateButton(ButtonFrame2Left, "Aura Hit Effect: " .. (Config.RainbowHitEffectEnabled and "ON" or "OFF"), function()
    Config.RainbowHitEffectEnabled = not Config.RainbowHitEffectEnabled
    rainbowHitButton.Text = "Aura Hit Effect: " .. (Config.RainbowHitEffectEnabled and "ON" or "OFF")
    sendNotification("Aura Hit Effect", Config.RainbowHitEffectEnabled and "Enabled" or "Disabled")

    local char = LocalPlayer.Character
    if char then
        local aura = char:FindFirstChild("SkibidiAura")
        if Config.RainbowHitEffectEnabled then
            if not aura then
                createSkibidiRedRizz(char)
            end
        else
            if aura then aura:Destroy() end
        end
    end
end)

task.defer(function()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if Config.RainbowHitEffectEnabled and not char:FindFirstChild("SkibidiAura") then
        createSkibidiRedRizz(char)
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    if Config.RainbowHitEffectEnabled then
        task.wait(1)
        if not char:FindFirstChild("SkibidiAura") then
            createSkibidiRedRizz(char)
        end
    end
end)

local lastHealth = {}
RunService.Heartbeat:Connect(function()
    if not Config.RainbowHitEffectEnabled then return end

    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local hum = plr and plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                local current = hum.Health
                local last = lastHealth[name] or current
                if current < last then
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = plr.Character
                    highlight.Adornee = plr.Character
                    highlight.FillTransparency = 1
                    highlight.OutlineTransparency = 0
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop

                    task.spawn(function()
                        local start = tick()
                        while tick() - start < 1 do
                            highlight.OutlineColor = rainbowColor()
                            task.wait(0.05)
                        end
                        highlight:Destroy()
                    end)
                end
                lastHealth[name] = current
            end
        end
    end
end)

local antiAfkEnabled = false
local antiAfkLoop

antiAfkButton = CreateButton(ButtonFrame2Left, "Anti AFK: OFF", function()
    antiAfkEnabled = not antiAfkEnabled
    antiAfkButton.Text = "Anti AFK: " .. (antiAfkEnabled and "ON" or "OFF")
    sendNotification("ANTI AFK", antiAfkEnabled and "ON" or "OFF")

    if antiAfkEnabled then
        antiAfkLoop = task.spawn(function()
            while antiAfkEnabled do
                task.wait(60)
                pcall(function()
                    local hum = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end)
            end
        end)
    else
        if antiAfkLoop then
            task.cancel(antiAfkLoop)
            antiAfkLoop = nil
        end
    end
end)

local function getClosestSelected()
    local closest, dist = nil, math.huge
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local d = (myHRP.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                if d < dist then
                    dist = d
                    closest = plr
                end
            end
        end
    end
    return closest
end

local animEnabled = false
local animTrack = nil
local bangConnection = nil

local function stopAnimAndTp()
    if animTrack then
        animTrack:Stop()
        animTrack = nil
    end
    if bangConnection then
        bangConnection:Disconnect()
        bangConnection = nil
    end
    animEnabled = false
end

bangButton = CreateButton(ButtonFrame2Left, "BangPlayer: OFF", function()
    animEnabled = not animEnabled
    
    if not animEnabled then
        stopAnimAndTp()
        bangButton.Text = "BangPlayer: OFF"
        sendNotification("BangPlayer", "Đã tắt")
    else
        local target = getClosestSelected()
        if not target then
            animEnabled = false
            bangButton.Text = "BangPlayer: OFF"
            sendNotification("BangPlayer", "Không tìm thấy mục tiêu trong danh sách!")
            return
        end

        local myChar = LocalPlayer.Character
        local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not (myHum and myHRP) then
            animEnabled = false
            bangButton.Text = "BangPlayer: OFF"
            sendNotification("BangPlayer", "Không tìm thấy nhân vật!")
            return
        end

        local anim = Instance.new("Animation")
        anim.AnimationId = myHum.RigType == Enum.HumanoidRigType.R6 and "rbxassetid://148840371" or "rbxassetid://5918726674"

        animTrack = myHum:LoadAnimation(anim)
        animTrack:Play()
        animTrack:AdjustSpeed(10)

        bangButton.Text = "BangPlayer: ON (" .. target.Name .. ")"
        sendNotification("BangPlayer", "Đang dính theo " .. target.Name)

        myHRP.CFrame = target.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)

        bangConnection = RunService.Heartbeat:Connect(function()
            if animEnabled and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                myHRP.CFrame = target.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
            else
                stopAnimAndTp()
                bangButton.Text = "BangPlayer: OFF"
                sendNotification("BangPlayer", "Mục tiêu không hợp lệ, đã tắt!")
            end
        end)
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    if animEnabled then
        task.wait(0.5)
        local target = getClosestSelected()
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local myChar = LocalPlayer.Character
            local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if myHum and myHRP then
                local anim = Instance.new("Animation")
                anim.AnimationId = myHum.RigType == Enum.HumanoidRigType.R6 and "rbxassetid://148840371" or "rbxassetid://5918726674"
                
                pcall(function()
                    myChar.Pants:Destroy()
                    myChar.Shirt:Destroy()
                end)

                animTrack = myHum:LoadAnimation(anim)
                animTrack:Play()
                animTrack:AdjustSpeed(10)

                bangConnection = RunService.Heartbeat:Connect(function()
                    if animEnabled and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                        myHRP.CFrame = target.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
                    else
                        stopAnimAndTp()
                        bangButton.Text = "BangPlayer: OFF"
                        sendNotification("BangPlayer", "Mục tiêu không hợp lệ, đã tắt!")
                    end
                end)
            end
        else
            stopAnimAndTp()
            bangButton.Text = "BangPlayer: OFF"
            sendNotification("BangPlayer", "Mục tiêu không hợp lệ, đã tắt!")
        end
    end
end)

noclipButton = CreateButton(ButtonFrame2Left, "Noclip: OFF", function()
    Config.NoclipEnabled = not Config.NoclipEnabled
    
    if Config.NoclipEnabled then
        if noclipConnection then noclipConnection:Disconnect() end
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
    end

    sendNotification("NOCLIP", Config.NoclipEnabled and "ON" or "OFF")
    noclipButton.Text = "Noclip: " .. (Config.NoclipEnabled and "ON" or "OFF")
end)

LocalPlayer.CharacterAdded:Connect(function()
    if Config.NoclipEnabled then
        task.wait(0.5)
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end)

local animations = {
    happier = "http://www.roblox.com/asset/?id=15609995579",
    happy   = "http://www.roblox.com/asset/?id=14352343065",
    fakedead = "rbxassetid://107771044135542",
}

local currentTrack = nil

local function stopAnimation()
    if currentTrack then
        currentTrack:Stop()
        currentTrack = nil
    end
end

local function playAnimation(animId)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChildOfClass("Humanoid") then return end
    local hum = char:FindFirstChildOfClass("Humanoid")

    if hum.MoveDirection.Magnitude > 0 then return end

    stopAnimation()

    local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    local track = animator:LoadAnimation(anim)
    track:Play()
    currentTrack = track
end

LocalPlayer.CharacterAdded:Connect(function()
    currentTrack = nil
end)

RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if char and currentTrack then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum and hum.MoveDirection.Magnitude > 0 then
            stopAnimation()
        end
    end
end)

CreateButton(ButtonFrame2Right, "Happier Jump", function()
    playAnimation(animations.happier)
end)

CreateButton(ButtonFrame2Right, "Happy", function()
    playAnimation(animations.happy)
end)

CreateButton(ButtonFrame2Right, "Fake Dead", function()
    playAnimation(animations.fakedead)
end)

local function giveClickTpTool()
    if clickTpTool then clickTpTool:Destroy() end
    clickTpTool = Instance.new("Tool")
    clickTpTool.RequiresHandle = false
    clickTpTool.Name = "ClickTP"
    clickTpTool.Parent = LocalPlayer.Backpack

    clickTpTool.Activated:Connect(function()
        local mouse = LocalPlayer:GetMouse()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if mouse and mouse.Hit then
                local targetPos = mouse.Hit.p + Vector3.new(0, 3, 0)
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
            end
        end
    end)
end

clickTpButton = CreateButton(ButtonFrame2Right, "Click TP: OFF", function()
    Config.clickTpEnabled = not Config.clickTpEnabled
    sendNotification("GIVECLICKTOOL", Config.clickTpEnabled and "ON" or "OFF")
    clickTpButton.Text = "Click TP: " .. (Config.clickTpEnabled and "ON" or "OFF")
    if Config.clickTpEnabled then
        giveClickTpTool()
        sendNotification("Click TP", "Đã cấp tool Click TP vào Backpack!")
    else
        if clickTpTool then
            clickTpTool:Destroy()
            clickTpTool = nil
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    if Config.clickTpEnabled then
        task.wait(0.5)
        giveClickTpTool()
    end
end)

saveWaypointButton = CreateButton(ButtonFrame2Right, "Save Waypoint", function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        savedWaypoint = LocalPlayer.Character.HumanoidRootPart.CFrame
        sendNotification("Waypoint", "Đã lưu vị trí hiện tại!")
    else
        sendNotification("Waypoint", "Không thể lưu vị trí!")
    end
end)

tpWaypointButton = CreateButton(ButtonFrame2Right, "TP to Waypoint", function()
    if savedWaypoint and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = savedWaypoint
        sendNotification("Waypoint", "Đã teleport tới vị trí đã lưu!")
    else
        sendNotification("Waypoint", "Chưa có vị trí được lưu!")
    end
end)

spinbotButton = CreateButton(ButtonFrame2Right, "Spinbot: " .. (Config.SpinbotEnabled and "ON" or "OFF"), function()
    Config.SpinbotEnabled = not Config.SpinbotEnabled
    spinbotButton.Text = "Spinbot: " .. (Config.SpinbotEnabled and "ON" or "OFF")
    sendNotification("Spinbot", Config.SpinbotEnabled and "Enabled" or "Disabled")
end)

local spinbotSpeedBox = Instance.new("TextBox")
spinbotSpeedBox.Size = UDim2.new(1, 0, 0, 20)
spinbotSpeedBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
spinbotSpeedBox.TextColor3 = Color3.new(1, 1, 1)
spinbotSpeedBox.Text = tostring(Config.SpinbotSpeed)
spinbotSpeedBox.PlaceholderText = "Speed"
spinbotSpeedBox.ClearTextOnFocus = false
spinbotSpeedBox.Font = Enum.Font.GothamBold
spinbotSpeedBox.TextSize = 12
spinbotSpeedBox.Parent = ButtonFrame2Right
Instance.new("UICorner", spinbotSpeedBox).CornerRadius = UDim.new(0, 4)

spinbotSpeedBox.FocusLost:Connect(function()
    local num = tonumber(spinbotSpeedBox.Text)
    if num then
        Config.SpinbotSpeed = num
    else
        spinbotSpeedBox.Text = tostring(Config.SpinbotSpeed)
    end
end)

RunService.RenderStepped:Connect(function(delta)
    if Config.SpinbotEnabled then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChild("Humanoid")
        if hrp and hum then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(Config.SpinbotSpeed) * delta, 0)
            hum.AutoRotate = false
        end
    else
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.AutoRotate = true end
    end
end)

antiFlingEnabled = false

antiFlingButton = CreateButton(ButtonFrame2Right, "Anti Fling: OFF", function()
    antiFlingEnabled = not antiFlingEnabled
    antiFlingButton.Text = "Anti Fling: " .. (antiFlingEnabled and "ON" or "OFF")
    sendNotification("Anti Fling", antiFlingEnabled and "Enabled" or "Disabled")
end)

if _G.__antifling_conn then
    _G.__antifling_conn:Disconnect()
end

_G.__antifling_conn = RunService.Heartbeat:Connect(function()
    if not antiFlingEnabled then return end
    pcall(function()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = plr.Character.HumanoidRootPart
                hrp.Velocity = Vector3.new(0, 0, 0)
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end)

local hiddenFling = false
local flingPower = 55000
local movel = 0.1

local function flingLoop()
    local lp = Players.LocalPlayer
    local hrp, c, vel

    task.spawn(function()
        while true do
            RunService.Heartbeat:Wait()
            if hiddenFling then
                while hiddenFling and not (c and c.Parent and hrp and hrp.Parent) do
                    RunService.Heartbeat:Wait()
                    c = lp.Character
                    hrp = c and c:FindFirstChild("HumanoidRootPart")
                end

                if hiddenFling and hrp then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                    RunService.RenderStepped:Wait()
                    if hrp.Parent then
                        hrp.Velocity = vel
                    end
                    RunService.Stepped:Wait()
                    if hrp.Parent then
                        hrp.Velocity = vel + Vector3.new(0, movel, 0)
                        movel = movel * -1
                    end
                end
            end
        end
    end)
end

flingLoop()

flintTouchButton = CreateButton(ButtonFrame2Right, "FlintTouch: OFF", function()
    hiddenFling = not hiddenFling
    sendNotification("FLINGTOUCH", hiddenFling and "ON" or "OFF")
    flintTouchButton.Text = "FlintTouch: " .. (hiddenFling and "ON" or "OFF")
end)

local function FlingAll()
    hiddenFling = true
    flintTouchButton.Text = "FlintTouch: ON"
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local targetRoot = plr.Character.HumanoidRootPart
            for i = 1, 10 do
                myRoot.CFrame = targetRoot.CFrame + Vector3.new(math.random(-2, 2), 0, math.random(-2, 2))
                task.wait(0.05)
                myRoot.CFrame = targetRoot.CFrame + Vector3.new(math.random(-2, 2), 0, math.random(-2, 2))
                task.wait(0.05)
            end
        end
    end
end

flingAllButton = CreateButton(ButtonFrame2Right, "Fling All", FlingAll)

local espGui = Instance.new("ScreenGui")
espGui.Name = "SafeESP"
espGui.ResetOnSpawn = false
espGui.IgnoreGuiInset = true
espGui.Parent = PlayerGui

local ESPs = {}

local function IsValidTarget(player)
    if not player 
        or not player.Character 
        or not player.Character:FindFirstChild("Humanoid") 
        or not player.Character:FindFirstChild("HumanoidRootPart") 
        or player.Character.Humanoid.Health <= 0 then
        return false
    end

    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    local koValue = bodyEffects and bodyEffects:FindFirstChild("K.O")
    if koValue and koValue.Value then
        return false
    end

    if player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
        return false
    end

    return true
end

local function CreateESP(player)
    if ESPs[player] or player == LocalPlayer then return end
    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 179, 186)
    label.TextSize = 16
    label.Font = Enum.Font.GothamBold
    label.Text = player.DisplayName
    label.TextStrokeTransparency = 0.5
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.Size = UDim2.new(0, 200, 0, 20)
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.Visible = false
    label.Parent = espGui

    local highlight = Instance.new("Highlight")
    highlight.Enabled = false
    highlight.FillTransparency = 0.6
    highlight.OutlineTransparency = 0.2
    highlight.FillColor = Color3.fromRGB(255, 179, 186)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.Adornee = player.Character
    highlight.Parent = espGui

    ESPs[player] = { label = label, highlight = highlight }
end

local function RemoveESP(player)
    if ESPs[player] then
        pcall(function()
            ESPs[player].label:Destroy()
            ESPs[player].highlight:Destroy()
        end)
        ESPs[player] = nil
    end
end

local function UpdateESP()
    if not Config.ESPEnabled then
        for _, v in pairs(ESPs) do
            v.label.Visible = false
            v.highlight.Enabled = false
        end
        return
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and IsValidTarget(player) then
            local character = player.Character
            local head = character:FindFirstChild("Head")
            if head then
                CreateESP(player)
                local headPos = head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
                local esp = ESPs[player]
                if esp then
                    local isSelected = Config.SelectedPlayers[player.Name]
                    esp.label.TextColor3 = isSelected and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 255, 255)
                    esp.highlight.FillColor = isSelected and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 255, 255)
                    if onScreen then
                        esp.label.Visible = true
                        esp.label.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y - 20)
                        esp.highlight.Enabled = true
                    else
                        esp.label.Visible = false
                        esp.highlight.Enabled = false
                    end
                end
            else
                RemoveESP(player)
            end
        else
            RemoveESP(player)
        end
    end
end

local function UpdateSpeed()
    if Config.SpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local humanoid = LocalPlayer.Character.Humanoid
        local moveDirection = humanoid.MoveDirection
        local speedAmount = Config.SpeedAmount / 8
        root.CFrame = root.CFrame + moveDirection * speedAmount
    end
end

local function UpdateFly(deltaTime)
    if Config.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local moveDirection = LocalPlayer.Character.Humanoid.MoveDirection
        local flySpeed = Config.FlySpeed
        local vertical = UserInputService:IsKeyDown(Enum.KeyCode.Space) and flySpeed / 8 or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and -flySpeed / 8 or 0
        root.CFrame = root.CFrame + moveDirection * deltaTime * flySpeed * 10
        root.CFrame = root.CFrame + Vector3.new(0, vertical, 0)
        root.Velocity = root.Velocity * Vector3.new(1, 0, 1) + Vector3.new(0, 1.9, 0)
    end
end

local function UpdatePlayerList()
    for _, cd in pairs(PlayerListFrame:GetChildren()) do
        if cd:IsA("TextButton") then cd:Destroy() end
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, -4, 0, 20)
            button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            button.BackgroundTransparency = 0.2
            button.TextColor3 = Color3.fromRGB(0, 0, 0)
            button.TextSize = 14
            button.Font = Enum.Font.Gotham
            button.AutoButtonColor = false
            button.Parent = PlayerListFrame
            local function UpdateButtonText()
                local isSelected = Config.SelectedPlayers[player.Name]
                button.Text = (isSelected and "✓ " or "") .. player.DisplayName
            end
            button.MouseButton1Click:Connect(function()
                Config.SelectedPlayers[player.Name] = not Config.SelectedPlayers[player.Name]
                UpdateButtonText()
            end)
            attachButtonEffects(button, 3)
            UpdateButtonText()
        end
    end
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Y then
        autoSelect = not autoSelect
        if autoSelect then
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    Config.SelectedPlayers[player.Name] = true
                end
            end
        else
            Config.SelectedPlayers = {}
        end
        UpdatePlayerList()
    end
end)

local hitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}

local function validPart(p)
    if not p or not p.Parent or not p.Parent:FindFirstChild("Humanoid") then return false end
    local player = Players:GetPlayerFromCharacter(p.Parent)
    if not player or not Config.SelectedPlayers[player.Name] then return false end
    for _, n in ipairs(hitParts) do
        if p.Name:lower() == n:lower() then return true end
    end
    return false
end

local function distToCursor(part)
    local v, vis = Camera:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UserInputService.TouchEnabled and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) or UserInputService:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - Vector2.new(m.X, m.Y)).Magnitude
end

local function click()
    if UserInputService.TouchEnabled then
        local touchPos = UserInputService:GetMouseLocation()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        if mouse1press then
            mouse1press()
            mouse1release()
        elseif mouse1click then
            mouse1click()
        end
    end
end

local function GetBestTargetPart()
    local bestPart, bestDist = nil, fovRadius
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and Config.SelectedPlayers[plr.Name] and IsValidTarget(plr) and plr.Character then
            for _, partName in ipairs(hitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

getgenv().Aimbot = {
    Status = true,
    Hitpart = "Head",
}

local function GetPing()
    if Config.CustomPing then
        return Config.CustomPing
    end
    local stats = game:GetService("Stats"):FindFirstChild("Network")
    local data = stats and stats:FindFirstChild("DataPing")
    return data and math.clamp(data:GetValue(), 10, 300) or 40
end

local function GetPredictedPosition(part)
    if not part or not part:IsA("BasePart") then return part.Position end
    local velocity = part.Velocity
    local origin = Camera.CFrame.Position
    local distance = (part.Position - origin).Magnitude
    local ping = GetPing()
    local delay = ping / 1000
    local distanceFactor = math.clamp(distance / 100, 1, 3)
    return part.Position + velocity * delay * distanceFactor
end

local function IsObstructed(origin, targetPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = Workspace:Raycast(origin, (targetPos - origin), raycastParams)
    if result and result.Instance and not result.Instance:IsDescendantOf(Player and Player.Character) then
        return true
    end
    return false
end

local function GetClosestValidPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and Config.SelectedPlayers[plr.Name] and IsValidTarget(plr) and plr.Character then
            local targetPart = plr.Character:FindFirstChild(getgenv().Aimbot.Hitpart)
            local targetHRP = plr.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and targetHRP then
                local dist = (myHRP.Position - targetHRP.Position).Magnitude
                if dist < shortestDistance then
                    closestPlayer = plr
                    shortestDistance = dist
                end
            end
        end
    end

    return closestPlayer
end

RunService.Heartbeat:Connect(function(deltaTime)
    UpdateESP()
    UpdateSpeed()
    UpdateFly(deltaTime)

    if Config.AimbotEnabled and getgenv().Aimbot.Status then
        Player = GetClosestValidPlayer()
        if Player and Player.Character and Player.Character:FindFirstChild(getgenv().Aimbot.Hitpart) then
            local part = Player.Character[getgenv().Aimbot.Hitpart]
            local predictedPos = GetPredictedPosition(part)
            if not IsObstructed(Camera.CFrame.Position, predictedPos) then
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, predictedPos)
            end
        end
    end

    if tbEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(0)
                if tbEnabled and distToCursor(cap) <= fovRadius then
                    local origin = Camera.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}

                    local result = Workspace:Raycast(origin, direction, rayParams)

                    if not result or result.Instance:IsDescendantOf(cap.Parent) then
                        click()
                    end
                end
            end)
        end
    end
end)

local Connections = {}
local function Connect(event, callback)
    local connection = event:Connect(callback)
    table.insert(Connections, connection)
    return connection
end

Connect(Players.PlayerRemoving, function(player)
    RemoveESP(player)
    UpdatePlayerList()
end)

Connect(Players.PlayerAdded, function(player)
    task.wait(math.random(2, 3))
    RemoveESP(player)
    if Config.SelectedPlayers[player.Name] then
        Config.SelectedPlayers[player.Name] = true 
    end
    UpdatePlayerList()
end)

task.spawn(function()
    while true do
        UpdatePlayerList()
        task.wait(math.random(12, 15))
    end
end)

local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local FOV_RADIUS = 200

local function GetClosestValidPlayer()
    local closest, shortestDist = nil, math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = plr.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                local distFromMouse = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if distFromMouse <= FOV_RADIUS and distFromMouse < shortestDist then
                    shortestDist = distFromMouse
                    closest = plr
                end
            end
        end
    end
    return closest
end

local selectGui = Instance.new("ScreenGui")
selectGui.Name = "SelectTargetGui"
selectGui.ResetOnSpawn = false
selectGui.Parent = CoreGui

local selectBtn = Instance.new("TextButton")
selectBtn.Size = UDim2.new(0, 110, 0, 35)
selectBtn.Position = UDim2.new(0, 300, 0, 200)
selectBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
selectBtn.Text = "Set Target"
selectBtn.Font = Enum.Font.GothamBold
selectBtn.TextSize = 14
selectBtn.TextColor3 = Color3.new(230, 230, 230)
selectBtn.Parent = selectGui
Instance.new("UICorner", selectBtn).CornerRadius = UDim.new(0, 8)

local dragging, dragStart, startPos
selectBtn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = selectBtn.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        selectBtn.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

selectBtn.MouseButton1Click:Connect(function()
    local target = GetClosestValidPlayer()
    if target then
        local displayName = target.DisplayName
        local username = target.Name

        if Config.SelectedPlayers[username] then
            Config.SelectedPlayers[username] = nil
            game.StarterGui:SetCore("SendNotification", {
                Title = "Set Target",
                Text = "Bỏ chọn: " .. displayName,
                Duration = 2
            })
        else
            Config.SelectedPlayers[username] = true
            game.StarterGui:SetCore("SendNotification", {
                Title = "Select Target",
                Text = "Đã chọn: " .. displayName,
                Duration = 2
            })
        end

        if UpdateSelectedPlayersUI then
            UpdateSelectedPlayersUI()
        end
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Set Target",
            Text = "Không tìm thấy mục tiêu trong FOV",
            Duration = 2
        })
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton3 then
        local target = GetClosestValidPlayer()
        if target then
            local displayName = target.DisplayName
            local username = target.Name

            if Config.SelectedPlayers[username] then
                Config.SelectedPlayers[username] = nil
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Set Target",
                    Text = "Bỏ chọn: " .. displayName,
                    Duration = 2
                })
            else
                Config.SelectedPlayers[username] = true
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Select Target",
                    Text = "Đã chọn: " .. displayName,
                    Duration = 2
                })
            end

            if UpdateSelectedPlayersUI then
                UpdateSelectedPlayersUI()
            end
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Set Target",
                Text = "Không tìm thấy mục tiêu trong FOV",
                Duration = 2
            })
        end
    end
end)

-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local localplayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Configuration
local ESP_ENABLED = false
local SHOOT_OFFSET = 2.8
local OFFSET_TO_PING_MULT = 1
local UPDATE_INTERVAL = 0.5
local RANDOM_DELAY = 0.1
local MAX_COIN_DISTANCE = 100
local ANTI_CHEAT_DELAY = 0.05

-- Variables
local playerData = {}
local espActive = ESP_ENABLED
local lastUpdate = tick()
local autoFarm = false
local lastShot = tick()
local isScriptRunning = false

-- ESP Container
local espcontainer = {
    objects = {},
    Add = function(self, object, config)
        if not espActive then return end
        pcall(function()
            if self.objects[object] then
                self.objects[object].highlight:Destroy()
                self.objects[object] = nil
            end
            local highlight = Instance.new("Highlight")
            highlight.Parent = object
            highlight.FillColor = config.AccentColor
            highlight.OutlineColor = config.AccentColor
            highlight.FillTransparency = 0.5
            highlight.OutlineTransparency = 0
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            self.objects[object] = { highlight = highlight }
            if config.ShowLabel then
                local billboard = Instance.new("BillboardGui")
                billboard.Parent = object
                billboard.Size = UDim2.new(0, 100, 0, 30)
                billboard.StudsOffset = Vector3.new(0, 3, 0)
                billboard.AlwaysOnTop = true
                local textLabel = Instance.new("TextLabel")
                textLabel.Parent = billboard
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Text = config.LabelText
                textLabel.TextColor3 = config.AccentColor
                textLabel.TextScaled = true
            end
        end)
    end,
    RemoveGroup = function(self, groupName)
        for object, data in pairs(self.objects) do
            if data.group == groupName then
                pcall(function()
                    data.highlight:Destroy()
                    if data.billboard then data.billboard:Destroy() end
                end)
                self.objects[object] = nil
            end
        end
    end,
    ClearAllGroups = function(self)
        for object, data in pairs(self.objects) do
            pcall(function()
                data.highlight:Destroy()
                if data.billboard then data.billboard:Destroy() end
            end)
        end
        self.objects = {}
    end
}

-- Game checks
local function isMurderMystery2()
    return ReplicatedStorage:FindFirstChild("Remotes") 
        and ReplicatedStorage.Remotes:FindFirstChild("Gameplay")
end

local function getMap()
    for _, o in ipairs(Workspace:GetChildren()) do
        if o:GetAttribute("MapID") and o:FindFirstChild("CoinContainer") and o:FindFirstChild("Spawns") then
            return o
        end
    end
    return nil
end

-- Role detection
local function findMurderer()
    if playerData then
        for player, data in pairs(playerData) do
            if data.Role == "Murderer" then
                local plr = Players:FindFirstChild(player)
                if plr and plr.Character then
                    return plr
                end
            end
        end
    end
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localplayer and plr.Character then
            if plr.Backpack:FindFirstChild("Knife") or (plr.Character and plr.Character:FindFirstChild("Knife")) then
                return plr
            end
        end
    end
    return nil
end

local function findSheriff()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and (plr.Backpack:FindFirstChild("Gun") or (plr.Character and plr.Character:FindFirstChild("Gun"))) then
            return plr
        end
    end
    if playerData then
        for player, data in pairs(playerData) do
            if data.Role == "Sheriff" then
                local plr = Players:FindFirstChild(player)
                if plr and plr.Character then
                    return plr
                end
            end
        end
    end
    return nil
end

local function findSheriffThatsNotMe()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localplayer and plr.Character and (plr.Backpack:FindFirstChild("Gun") or (plr.Character and plr.Character:FindFirstChild("Gun"))) then
            return plr
        end
    end
    if playerData then
        for player, data in pairs(playerData) do
            if data.Role == "Sheriff" and Players:FindFirstChild(player) ~= localplayer then
                local plr = Players:FindFirstChild(player)
                if plr and plr.Character then
                    return plr
                end
            end
        end
    end
    return nil
end

-- ESP functions
local function reloadESP()
    if not espActive then return end
    espcontainer:RemoveGroup("players")
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player ~= localplayer then
            task.spawn(function()
                if player == findMurderer() then
                    espcontainer:Add(player.Character, {
                        AccentColor = Color3.new(1, 0, 0.0156863),
                        ArrowShow = true,
                        ArrowMinDistance = 999999,
                        ArrowSize = UDim2.new(0, 40, 0, 40),
                        LabelText = "Murderer",
                        ShowLabel = true,
                        GroupName = "players"
                    })
                elseif player == findSheriff() then
                    espcontainer:Add(player.Character, {
                        AccentColor = Color3.new(0, 0.6, 1),
                        ArrowShow = false,
                        ShowLabel = false,
                        GroupName = "players"
                    })
                else
                    espcontainer:Add(player.Character, {
                        AccentColor = Color3.new(0, 1, 0.0313725),
                        ArrowShow = false,
                        ShowLabel = false,
                        GroupName = "players"
                    })
                end
            end)
        end
    end
end

-- Predicted position
local function getPredictedPosition(player, shootOffset)
    local success, result = pcall(function()
        if not player.Character then
            return Vector3.new(0, 0, 0)
        end
        local playerHRP = player.Character:FindFirstChild("UpperTorso")
        local playerHum = player.Character:FindFirstChild("Humanoid")
        if not playerHRP or not playerHum then
            return Vector3.new(0, 0, 0)
        end
        local playerPosition = playerHRP.Position
        local velocity = playerHRP.AssemblyLinearVelocity
        local playerMoveDirection = playerHum.MoveDirection
        local predictedPosition = playerPosition + (velocity * Vector3.new(0, 0.5, 0)) * (shootOffset / 15) + playerMoveDirection * shootOffset
        predictedPosition = predictedPosition * (((localplayer:GetNetworkPing() * 1000) * ((OFFSET_TO_PING_MULT - 1) * 0.01)) + 1)
        return predictedPosition
    end)
    if not success then
        return Vector3.new(0, 0, 0)
    end
    return result
end

-- Shoot Murderer
local function shootMurderer()
    if tick() - lastShot < 0.5 then return end 
    lastShot = tick()
    if findSheriff() ~= localplayer then
        return
    end
    local murderer = findMurderer() or findSheriffThatsNotMe()
    if not murderer then
        return
    end
    if not localplayer.Character:FindFirstChild("Gun") then
        local hum = localplayer.Character:FindFirstChild("Humanoid")
        if localplayer.Backpack:FindFirstChild("Gun") then
            hum:EquipTool(localplayer.Backpack:FindFirstChild("Gun"))
            task.wait(math.random(0.05, 0.1) + ANTI_CHEAT_DELAY)
        else
            return
        end
    end
    local murdererHRP = murderer.Character:FindFirstChild("HumanoidRootPart")
    if not murdererHRP then
        return
    end
    local predictedPosition = getPredictedPosition(murderer, SHOOT_OFFSET)
    if predictedPosition == Vector3.new(0, 0, 0) then return end
    local args = {
        [1] = 1,
        [2] = predictedPosition,
        [3] = "AH2"
    }
    pcall(function()
        localplayer.Character.Gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
    end)
    task.wait(math.random(0, ANTI_CHEAT_DELAY))
end

-- AutoFarm Coins
local function autoFarmCoins()
    local k = TweenService
    local g = Players.LocalPlayer
    local r = g.Character or g.CharacterAdded:Wait()
    local A = r:WaitForChild("HumanoidRootPart", 5)
    local a = r:WaitForChild("Humanoid", 5)
    if not A or not a then
        return
    end
    local function findMap()
        for _, E in ipairs(Workspace:GetChildren()) do
            if E:GetAttribute("MapID") and E:FindFirstChild("CoinContainer") then
                return E
            end
        end
        task.wait(0.5)
        return nil
    end
    local function findCoin()
        local C = findMap()
        if not C or not C:FindFirstChild("CoinContainer") then return nil end
        local D, i = nil, math.huge
        for _, l in ipairs(C.CoinContainer:GetChildren()) do
            local q = l:FindFirstChild("CoinVisual")
            if q and not q:GetAttribute("Collected") and l.Parent then
                local dist = (A.Position - l.Position).Magnitude
                if dist < i and dist < MAX_COIN_DISTANCE then
                    D = l
                    i = dist
                end
            end
        end
        return D
    end
    local function moveToCoin(B)
        if not B or not B.Parent then return end
        a:ChangeState(11)
        local t = (A.Position - B.Position).Magnitude
        if t > MAX_COIN_DISTANCE then return end
        local offset = Vector3.new(math.random(-5, 5)/10, 0, math.random(-5, 5)/10)
        local f = k:Create(A, TweenInfo.new(t / 25, Enum.EasingStyle.Linear), {CFrame = B.CFrame * CFrame.Angles(0, math.rad(math.random(-10, 10)), 0) + offset})
        f:Play()
        f.Completed:Wait()
    end
    while autoFarm do
        local z = findCoin()
        if z then
            moveToCoin(z)
            local h = z:FindFirstChild("CoinVisual")
            while h and not h:GetAttribute("Collected") and h.Parent and autoFarm do
                local x = findCoin()
                if x and x ~= z then
                    break
                end
                task.wait(0.1 + math.random(0, ANTI_CHEAT_DELAY))
            end
        end
        task.wait(math.random(0.1, 0.3))
    end
end

-- Auto-Shoot when Sheriff and Autofarm is Active
local function checkLineOfSight(startPos, endPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {localplayer.Character, Workspace:FindFirstChild("CoinContainer")}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    local raycastResult = Workspace:Raycast(startPos, (endPos - startPos).Unit * (endPos - startPos).Magnitude, raycastParams)
    return not raycastResult or raycastResult.Instance:IsDescendantOf(findMurderer().Character)
end

local lastKillAll = tick()

RunService.Heartbeat:Connect(function()
    if not autoFarm or not isScriptRunning then return end
    
    if findSheriff() == localplayer then
        local murderer = findMurderer()
        if murderer and murderer.Character and murderer.Character:FindFirstChild("HumanoidRootPart") and localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart") then
            local startPos = localplayer.Character.HumanoidRootPart.Position
            local endPos = murderer.Character.HumanoidRootPart.Position
            if checkLineOfSight(startPos, endPos) then
                task.spawn(shootMurderer)
            end
        end
    end
    
    if findMurderer() == localplayer and tick() - lastKillAll >= 1 then
        lastKillAll = tick()
        if not localplayer.Character:FindFirstChild("Knife") then
            local hum = localplayer.Character:FindFirstChild("Humanoid")
            if localplayer.Backpack:FindFirstChild("Knife") then
                hum:EquipTool(localplayer.Backpack:FindFirstChild("Knife"))
                task.wait(0.1)
            else
                sendNotification("You don't have the knife..?")
                return
            end
        end

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= localplayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local targetPart = player.Character:FindFirstChild("HumanoidRootPart")
                targetPart.Anchored = true
                targetPart.CFrame = localplayer.Character:FindFirstChild("HumanoidRootPart").CFrame + localplayer.Character:FindFirstChild("HumanoidRootPart").CFrame.LookVector * 1
                task.wait(0.05)
            end
        end

        local args = { [1] = "Slash" }
        localplayer.Character.Knife.Stab:FireServer(unpack(args))
        task.wait(0.1)
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= localplayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character:FindFirstChild("HumanoidRootPart").Anchored = false
            end
        end
        sendNotification("Auto Kill All executed.")
    end
end)

function miniFling(playerToFling)
    local Character = localplayer.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = playerToFling.Character
    local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter and TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if not Character or not Humanoid or not RootPart or not TCharacter then
        sendNotification("Không tìm thấy nhân vật hợp lệ của bạn hoặc mục tiêu.")
        return
    end

    if not TRootPart and not THead and not Handle then
        sendNotification("Không tìm thấy bộ phận hợp lệ để fling.")
        return
    end

    if THumanoid and THumanoid.Sit then
        sendNotification("Mục tiêu đang ngồi, không thể fling.")
        return
    end

    if RootPart.Velocity.Magnitude < 50 then
        getgenv().OldPos = RootPart.CFrame
    end

    if THead then
        workspace.CurrentCamera.CameraSubject = THead
    elseif Handle then
        workspace.CurrentCamera.CameraSubject = Handle
    elseif THumanoid then
        workspace.CurrentCamera.CameraSubject = THumanoid
    end

    local function FPos(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
        RootPart.Velocity = Vector3.new(9e7, 9e7, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    local function SFBasePart(BasePart)
        local TimeToWait = 2
        local Time = tick()
        local Angle = 0

        repeat
            if RootPart and THumanoid and BasePart and BasePart.Parent and Humanoid.Health > 0 then
                if BasePart.Velocity.Magnitude < 50 then
                    Angle = Angle + 100
                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                else
                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                    task.wait()
                end
            else
                break
            end
        until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TCharacter or not TCharacter.Parent or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
    end

    workspace.FallenPartsDestroyHeight = 0/0

    local BV = Instance.new("BodyVelocity")
    BV.Name = "FlingVelocity"
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    if TRootPart and THead and (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
        SFBasePart(THead)
    elseif TRootPart then
        SFBasePart(TRootPart)
    elseif THead then
        SFBasePart(THead)
    elseif Handle then
        SFBasePart(Handle)
    else
        sendNotification("Không tìm thấy bộ phận hợp lệ để fling.")
    end

    BV:Destroy()
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    workspace.CurrentCamera.CameraSubject = Humanoid

    if getgenv().OldPos then
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 0.5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 0.5, 0))
            Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            for _, part in ipairs(Character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Velocity = Vector3.new(0, 0, 0)
                    part.RotVelocity = Vector3.new(0, 0, 0)
                end
            end
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
    end
    workspace.FallenPartsDestroyHeight = getgenv().FPDH or -500
    sendNotification("Đã fling " .. playerToFling.Name)
end

Workspace.ChildAdded:Connect(function(ch)
    if ch == getMap() and espActive then
        task.spawn(function()
            task.wait(math.random(1, 2))
            if findMurderer() then
                reloadESP()
            end
        end)
    end
end)

Workspace.ChildRemoved:Connect(function(ch)
    if ch == getMap() and espActive then
        playerData = {}
        espcontainer:ClearAllGroups()
    end
end)

localplayer.CharacterAdded:Connect(function()
    task.wait(math.random(0.5, 1.5))
    if autoFarm then
        task.spawn(autoFarmCoins)
    end
    if espActive then
        reloadESP()
    end
end)

Players.PlayerAdded:Connect(function(player)
    if player ~= localplayer then
        player.CharacterAdded:Connect(function()
            if espActive then
                task.wait(math.random(0.5, 1.5))
                reloadESP()
            end
        end)
    end
end)

Players.PlayerRemoving:Connect(function()
    if espActive then
        task.wait(math.random(0.5, 1.5))
        reloadESP()
    end
end)

local function initialize()
    local success = pcall(function()
        localplayer:WaitForChild("PlayerGui", 10)
        ReplicatedStorage:WaitForChild("Remotes", 10):WaitForChild("Gameplay", 10):WaitForChild("PlayerDataChanged", 10)
    end)
    if not success or not isMurderMystery2() then
        return
    end
    isScriptRunning = true
    pcall(function()
        local gameplay = ReplicatedStorage.Remotes.Gameplay.PlayerDataChanged
        gameplay.OnClientEvent:Connect(function(data)
            playerData = data
            if espActive then
                reloadESP()
            end
        end)
    end)
    if espActive then
        reloadESP()
    end
end

pcall(initialize)

local function saveConfig()
    local json = game:GetService("HttpService"):JSONEncode(Config)
    writefile("dhuyx_config.json", json)
end

local function loadConfig()
    if isfile("dhuyx_config.json") then
        local json = readfile("dhuyx_config.json")
        local loadedConfig = game:GetService("HttpService"):JSONDecode(json)
        for k, v in pairs(loadedConfig) do
            Config[k] = v
        end
    end
end

loadConfig()

LocalPlayer.CharacterAdded:Connect(saveConfig)
Players.PlayerRemoving:Connect(saveConfig)